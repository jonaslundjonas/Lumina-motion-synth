<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lumina Motion Synth</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #4fd1c5;
            margin-top: -6px;
            box-shadow: 0 0 10px rgba(79, 209, 197, 0.5);
            border: 1px solid #000;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #2d3748; 
            border-radius: 2px;
            border: 1px solid #1a202c;
        }
        input[type=range]:focus {
            outline: none;
        }
        
        /* Vertical Slider Specifics */
        input[type=range][style*="slider-vertical"] {
             width: 8px; 
        }
        .vertical-slider {
            -webkit-appearance: slider-vertical; 
            width: 20px;
            accent-color: #4fd1c5; 
            background: transparent;
        }

        .screen-container {
            box-shadow: inset 0 0 20px rgba(0,0,0,0.9);
            border: 1px solid #333;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        
        .screen-hold-active {
            border-color: #4fd1c5;
            box-shadow: inset 0 0 30px rgba(79, 209, 197, 0.3);
        }

        body {
            overscroll-behavior: none;
            touch-action: manipulation;
            background-color: #050505; 
        }
        
        .control-group {
            background: rgba(10, 10, 10, 0.85);
            border: 1px solid #2d3748;
            border-radius: 0.5rem;
            padding: 0.75rem;
            backdrop-filter: blur(4px);
        }

        #touch-pad:active {
            background: rgba(79, 209, 197, 0.1);
            border-color: #4fd1c5;
        }

        .vertical-range-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .hold-active {
            background-color: #4fd1c5 !important;
            color: #1a202c !important;
            box-shadow: 0 0 15px rgba(79, 209, 197, 0.6);
            border-color: #fff !important;
        }

        /* Toggle Button Styling */
        .toggle-btn {
            background-color: #1a202c;
            color: #718096;
            border: 1px solid #4a5568;
        }
        .toggle-btn.active {
            background-color: #2d3748;
            color: #4fd1c5;
            border-color: #4fd1c5;
            box-shadow: 0 0 5px rgba(79, 209, 197, 0.3);
        }

        select {
            background-color: #000;
            color: #e2e8f0;
            border: 1px solid #4a5568;
            border-radius: 0.25rem;
            padding: 0.25rem;
            font-size: 0.7rem;
            width: 100%;
            margin-bottom: 2px;
        }
    </style>
</head>
<body class="text-gray-300 font-sans h-screen flex flex-col overflow-hidden relative">

    <!-- Background Particles Canvas -->
    <canvas id="particle-canvas" class="absolute top-0 left-0 w-full h-full pointer-events-none z-0"></canvas>

    <!-- Header -->
    <header class="flex-none p-3 border-b border-gray-800 flex justify-between items-center bg-black/30 backdrop-blur-md z-10">
        <h1 class="text-xl font-bold text-teal-400 tracking-wider">LUMINA <span class="text-xs text-gray-500 font-normal">MOTION SYNTH</span></h1>
        
        <div class="flex items-center gap-2">
            <span class="text-[10px] text-teal-600 animate-pulse hidden" id="status-indicator">‚óè LIVE</span>
        </div>
        
        <button id="power-btn" class="bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-4 rounded shadow-[0_0_10px_rgba(239,68,68,0.5)] transition-colors">
            START SYSTEM
        </button>
    </header>

    <!-- Main Visual Area -->
    <div id="main-screen" class="flex-none relative h-64 bg-black/30 screen-container w-full overflow-hidden z-10 backdrop-blur-sm">
        <canvas id="visualizer" class="absolute top-0 left-0 w-full h-full z-10 opacity-80 pointer-events-none"></canvas>
        <video id="webcam" class="absolute top-0 left-0 w-full h-full object-cover opacity-30 z-0 hidden" playsinline muted></video>
        
        <!-- Touch Surface Overlay -->
        <div id="touch-pad" class="absolute top-0 left-0 w-full h-full z-20 cursor-crosshair flex flex-col items-center justify-center p-4">
            <span class="pointer-events-none text-gray-400 text-xs select-none opacity-60 font-bold mb-1 bg-black/50 px-2 rounded text-center" id="pad-hint">
                Touch to Play
            </span>
            <div class="pointer-events-none text-[10px] text-teal-500 opacity-60 flex justify-between w-full absolute bottom-2 px-4 font-mono">
                <span id="label-x-low">Low</span>
                <span id="label-x-high">High</span>
            </div>
            <div class="pointer-events-none text-[10px] text-teal-500 opacity-60 flex flex-col justify-between h-full absolute right-2 py-4 items-end font-mono">
                <span id="label-y-high">High</span>
                <span id="label-y-low">Low</span>
            </div>
        </div>

        <div id="sensor-feedback" class="absolute top-2 right-2 z-30 flex flex-col gap-1 items-end pointer-events-none">
            <span class="bg-black/60 px-2 py-0.5 rounded text-[10px] text-teal-300 hidden font-mono border border-teal-900" id="cam-val-display">CAM: 0%</span>
            <span class="bg-black/60 px-2 py-0.5 rounded text-[10px] text-purple-300 hidden font-mono border border-purple-900" id="tilt-val-display">TILT: 0%</span>
        </div>
    </div>

    <!-- Controls Container -->
    <main class="flex-1 overflow-y-auto p-4 space-y-4 z-10">
        
        <!-- Global Controls -->
        <div class="control-group flex items-center justify-between gap-4">
            <div class="flex-1">
                <label class="text-[10px] font-bold text-teal-500 uppercase block mb-1">Master Volume</label>
                <input type="range" id="master-vol" min="0" max="1" step="0.01" value="0.5">
            </div>
            <div class="flex-none">
                <button id="hold-btn" class="border-2 border-teal-600 text-teal-500 text-xs font-bold py-2 px-4 rounded transition-all hover:bg-teal-900/50">
                    HOLD NOTE
                </button>
            </div>
        </div>

        <!-- INPUT CONFIGURATION -->
        <div class="control-group border border-gray-700">
            <h3 class="text-xs font-bold text-gray-400 uppercase mb-2">Input Sources</h3>
            <div class="grid grid-cols-2 gap-3">
                
                <!-- Camera Config -->
                <div class="bg-black/40 p-2 rounded border border-gray-800">
                    <button class="toggle-btn w-full py-1 text-xs rounded mb-2 transition-colors font-bold active" id="btn-toggle-cam">ENABLE CAMERA</button>
                    <div id="cam-controls" class="transition-opacity">
                        <div class="flex justify-between items-center mb-1">
                            <label class="text-[10px] text-gray-500">Sensitivity</label>
                            <button id="calibrate-btn" class="text-[9px] bg-gray-800 px-2 py-0.5 rounded text-white border border-gray-700">Calib</button>
                        </div>
                        <input type="range" id="sensitivity" min="0" max="100" value="60">
                    </div>
                </div>

                <!-- Tilt Config -->
                <div class="bg-black/40 p-2 rounded border border-gray-800">
                    <button class="toggle-btn w-full py-1 text-xs rounded mb-2 transition-colors font-bold active" id="btn-toggle-tilt">ENABLE TILT</button>
                    <div id="tilt-controls" class="transition-opacity">
                        <div class="flex justify-between items-center mb-1">
                            <label class="text-[10px] text-gray-500">Range Scale</label>
                            <button id="sensor-perm-btn" class="text-[9px] bg-purple-900 px-2 py-0.5 rounded text-white hidden">Permit</button>
                        </div>
                        <input type="range" id="tilt-sensitivity" min="0.5" max="3.0" step="0.1" value="1.5">
                    </div>
                </div>
            </div>
        </div>

        <!-- MODULATION MATRIX -->
        <div class="control-group border border-teal-900/50 shadow-[0_0_15px_rgba(20,184,166,0.05)]">
            <h3 class="text-xs font-bold text-teal-500 uppercase mb-3 flex items-center gap-2">
                <span class="w-2 h-2 rounded-full bg-teal-500 shadow-[0_0_5px_#4fd1c5]"></span> Dual Modulation Matrix
            </h3>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-3">
                <!-- Camera -->
                <div>
                    <label class="block text-[10px] font-bold text-teal-400 mb-1">Camera Inputs</label>
                    <select id="map-camera-1" class="focus:border-teal-500 focus:outline-none">
                        <option value="pitch">Pitch</option>
                        <option value="filter">Filter</option>
                        <option value="lfoRate">LFO Rate</option>
                        <option value="lfoDepth">LFO Depth</option>
                        <option value="resonance">Resonance</option>
                        <option value="distortion">Distortion</option>
                        <option value="reverbMix" selected>Reverb Mix</option>
                        <option value="delayMix">Delay Mix</option>
                        <option value="none">None</option>
                    </select>
                    <select id="map-camera-2" class="focus:border-teal-500 focus:outline-none">
                        <option value="pitch">Pitch</option>
                        <option value="filter">Filter</option>
                        <option value="lfoRate">LFO Rate</option>
                        <option value="lfoDepth">LFO Depth</option>
                        <option value="resonance">Resonance</option>
                        <option value="distortion">Distortion</option>
                        <option value="reverbMix">Reverb Mix</option>
                        <option value="delayMix">Delay Mix</option>
                        <option value="none" selected>None</option>
                    </select>
                </div>

                <!-- Tilt -->
                <div>
                    <label class="block text-[10px] font-bold text-purple-400 mb-1">Tilt Inputs</label>
                    <select id="map-tilt-1" class="focus:border-teal-500 focus:outline-none">
                        <option value="pitch" selected>Pitch</option>
                        <option value="filter">Filter</option>
                        <option value="lfoRate">LFO Rate</option>
                        <option value="lfoDepth">LFO Depth</option>
                        <option value="resonance">Resonance</option>
                        <option value="distortion">Distortion</option>
                        <option value="reverbMix">Reverb Mix</option>
                        <option value="delayMix">Delay Mix</option>
                        <option value="none">None</option>
                    </select>
                    <select id="map-tilt-2" class="focus:border-teal-500 focus:outline-none">
                        <option value="pitch">Pitch</option>
                        <option value="filter">Filter</option>
                        <option value="lfoRate">LFO Rate</option>
                        <option value="lfoDepth">LFO Depth</option>
                        <option value="resonance">Resonance</option>
                        <option value="distortion">Distortion</option>
                        <option value="reverbMix">Reverb Mix</option>
                        <option value="delayMix">Delay Mix</option>
                        <option value="none" selected>None</option>
                    </select>
                </div>

                <!-- Touch X -->
                <div>
                    <label class="block text-[10px] font-bold text-gray-400 mb-1">Touch X Inputs</label>
                    <select id="map-touch-x-1" class="focus:border-teal-500 focus:outline-none">
                        <option value="pitch">Pitch</option>
                        <option value="filter" selected>Filter</option>
                        <option value="lfoRate">LFO Rate</option>
                        <option value="lfoDepth">LFO Depth</option>
                        <option value="resonance">Resonance</option>
                        <option value="distortion">Distortion</option>
                        <option value="reverbMix">Reverb Mix</option>
                        <option value="delayMix">Delay Mix</option>
                        <option value="none">None</option>
                    </select>
                    <select id="map-touch-x-2" class="focus:border-teal-500 focus:outline-none">
                        <option value="pitch">Pitch</option>
                        <option value="filter">Filter</option>
                        <option value="lfoRate">LFO Rate</option>
                        <option value="lfoDepth">LFO Depth</option>
                        <option value="resonance">Resonance</option>
                        <option value="distortion">Distortion</option>
                        <option value="reverbMix">Reverb Mix</option>
                        <option value="delayMix">Delay Mix</option>
                        <option value="none" selected>None</option>
                    </select>
                </div>

                <!-- Touch Y -->
                <div>
                    <label class="block text-[10px] font-bold text-gray-400 mb-1">Touch Y Inputs</label>
                    <select id="map-touch-y-1" class="focus:border-teal-500 focus:outline-none">
                        <option value="pitch">Pitch</option>
                        <option value="filter">Filter</option>
                        <option value="lfoRate" selected>LFO Rate</option>
                        <option value="lfoDepth">LFO Depth</option>
                        <option value="resonance">Resonance</option>
                        <option value="distortion">Distortion</option>
                        <option value="reverbMix">Reverb Mix</option>
                        <option value="delayMix">Delay Mix</option>
                        <option value="none">None</option>
                    </select>
                    <select id="map-touch-y-2" class="focus:border-teal-500 focus:outline-none">
                        <option value="pitch">Pitch</option>
                        <option value="filter">Filter</option>
                        <option value="lfoRate">LFO Rate</option>
                        <option value="lfoDepth">LFO Depth</option>
                        <option value="resonance">Resonance</option>
                        <option value="distortion">Distortion</option>
                        <option value="reverbMix">Reverb Mix</option>
                        <option value="delayMix">Delay Mix</option>
                        <option value="none" selected>None</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Filter & Envelope -->
        <div class="control-group">
            <h3 class="text-xs font-bold text-teal-500 uppercase mb-3">Filter & Envelope</h3>
            <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-xs font-bold mb-1">Base Cutoff</label>
                    <input type="range" id="filter-cutoff" min="50" max="5000" value="1040">
                </div>
                <div>
                    <label class="block text-xs font-bold mb-1">Resonance</label>
                    <input type="range" id="filter-res" min="0" max="20" value="11.2">
                </div>
            </div>
            
            <!-- Filter ADSR -->
            <div class="border-t border-gray-700 pt-2">
                <div class="flex justify-between items-center mb-1">
                    <span class="text-[10px] text-gray-400 uppercase">Filter Env</span>
                    <div class="w-1/3 flex items-center gap-1">
                         <label class="text-[9px] font-bold">Amt</label>
                         <input type="range" id="f-amt" min="0" max="5000" value="2000">
                    </div>
                </div>
                <div class="grid grid-cols-4 gap-1 text-center">
                    <div class="vertical-range-container">
                        <input type="range" id="f-atk" min="0.01" max="2" step="0.01" value="0.1" class="vertical-slider">
                    </div>
                    <div class="vertical-range-container">
                        <input type="range" id="f-dec" min="0.01" max="2" step="0.01" value="0.3" class="vertical-slider">
                    </div>
                    <div class="vertical-range-container">
                        <input type="range" id="f-sus" min="0" max="1" step="0.01" value="0.5" class="vertical-slider">
                    </div>
                    <div class="vertical-range-container">
                        <input type="range" id="f-rel" min="0.01" max="3" step="0.01" value="1.0" class="vertical-slider">
                    </div>
                    <div class="text-[9px] text-gray-500">A</div>
                    <div class="text-[9px] text-gray-500">D</div>
                    <div class="text-[9px] text-gray-500">S</div>
                    <div class="text-[9px] text-gray-500">R</div>
                </div>
            </div>
        </div>

        <!-- Amp Envelope & Oscillator -->
        <div class="grid grid-cols-2 gap-4">
            <!-- Amp ADSR (Narrower) -->
            <div class="control-group">
                <h3 class="text-xs font-bold text-teal-500 uppercase mb-2">Amp Env</h3>
                <div class="grid grid-cols-4 gap-1 text-center">
                    <div class="vertical-range-container">
                        <input type="range" id="atk" min="0.01" max="2" step="0.01" value="0.05" class="vertical-slider">
                    </div>
                    <div class="vertical-range-container">
                        <input type="range" id="dec" min="0.01" max="2" step="0.01" value="0.2" class="vertical-slider">
                    </div>
                    <div class="vertical-range-container">
                        <input type="range" id="sus" min="0" max="1" step="0.01" value="0.8" class="vertical-slider">
                    </div>
                    <div class="vertical-range-container">
                        <input type="range" id="rel" min="0.01" max="3" step="0.01" value="0.5" class="vertical-slider">
                    </div>
                    <div class="text-[9px] text-gray-500">A</div>
                    <div class="text-[9px] text-gray-500">D</div>
                    <div class="text-[9px] text-gray-500">S</div>
                    <div class="text-[9px] text-gray-500">R</div>
                </div>
            </div>

            <!-- Oscillator & LFO -->
            <div class="flex flex-col gap-2">
                <div class="control-group flex-1">
                    <h3 class="text-xs font-bold text-teal-500 uppercase mb-2">Oscillator</h3>
                    <div class="grid grid-cols-2 gap-1 mb-2">
                        <button class="wave-btn py-2 bg-black hover:bg-gray-900 rounded text-[10px] border border-gray-700" data-type="sine">Sine</button>
                        <button class="wave-btn py-2 bg-black hover:bg-gray-900 rounded text-[10px] border border-gray-700" data-type="sawtooth">Saw</button>
                        <button class="wave-btn py-2 bg-black hover:bg-gray-900 rounded text-[10px] border border-gray-700" data-type="square">Sqr</button>
                        <button class="wave-btn py-2 bg-black hover:bg-gray-900 rounded text-[10px] border border-gray-700" data-type="triangle">Tri</button>
                    </div>
                    <div class="text-[9px] text-gray-500 mb-1">Distortion Drive</div>
                    <input type="range" id="dist-drive" min="0" max="100" value="0">
                </div>
            </div>
        </div>

        <!-- Effects & LFO -->
        <div class="control-group">
            <h3 class="text-xs font-bold text-teal-500 uppercase mb-3">Effects & LFO</h3>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-[10px] mb-1">Delay</label>
                    <input type="range" id="delay-mix" min="0" max="1" step="0.01" value="0">
                    <label class="block text-[10px] mt-2 mb-1">Reverb</label>
                    <input type="range" id="reverb-mix" min="0" max="1" step="0.01" value="0">
                </div>
                <div>
                     <div class="flex justify-between mb-1">
                        <label class="text-[10px]">LFO Rate</label>
                        <select id="lfo-target" class="w-16 h-4 text-[9px] p-0 border-gray-700">
                            <option value="pitch">Pitch</option>
                            <option value="filter">Filter</option>
                            <option value="none" selected>Off</option>
                        </select>
                    </div>
                    <input type="range" id="lfo-rate" min="0.1" max="20" step="0.1" value="3.1">
                    <label class="block text-[10px] mt-2 mb-1">LFO Depth</label>
                    <input type="range" id="lfo-depth" min="0" max="1000" value="700">
                </div>
            </div>
             <input type="range" id="delay-time" min="0" max="1" step="0.01" value="0.3" class="hidden"> <!-- Hidden but functional -->
        </div>

    </main>

    <footer class="flex-none p-3 text-center text-[10px] text-gray-500 border-t border-gray-800 bg-black/90 z-10 font-mono tracking-widest uppercase">
        Created by Jonas Lund 2025
    </footer>

    <script>
        // --- PARTICLE SYSTEM ---
        const particleCanvas = document.getElementById('particle-canvas');
        const pCtx = particleCanvas.getContext('2d');
        let particles = [];
        
        function resizeParticles() {
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeParticles);
        resizeParticles();

        class Particle {
            constructor() {
                this.reset();
            }
            reset() {
                // Random position across the entire screen
                this.x = Math.random() * particleCanvas.width;
                this.y = Math.random() * particleCanvas.height;
                
                // Random angle and Slower Speed (0.2 - 0.7)
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 0.5 + 0.2; 
                
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.size = Math.random() * 2 + 0.5;
                // Vary opacity for twinkling effect
                this.alpha = Math.random() * 0.5 + 0.2; 
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                // Wrap around edges for infinite random flow
                if(this.x < 0) this.x = particleCanvas.width;
                if(this.x > particleCanvas.width) this.x = 0;
                if(this.y < 0) this.y = particleCanvas.height;
                if(this.y > particleCanvas.height) this.y = 0;
            }
            draw() {
                pCtx.beginPath();
                pCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                pCtx.fillStyle = `rgba(79, 209, 197, ${this.alpha})`;
                pCtx.fill();
            }
        }

        function initParticles() {
            for(let i=0; i<200; i++) particles.push(new Particle());
            animateParticles();
        }

        function animateParticles() {
            pCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            particles.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(animateParticles);
        }

        initParticles();

        // --- AUDIO ENGINE ---
        let audioCtx;
        let oscillator;
        let gainNode; 
        let masterGainNode; 
        let filterNode;
        let lfo;
        let lfoGain;
        let distGain; // Input gain for distortion drive
        let distNode; // Static wave shaper
        let distComp; // Compensation gain (optional, simplifies output level)
        let analyser;
        
        let delayNode, delayFeedback, delayDry, delayWet;
        let reverbNode, reverbDry, reverbWet;

        let isPlaying = false;
        let isHoldActive = false; 
        const ENVELOPE_PEAK = 0.8; 

        // --- GLOBAL INPUT STATE (Normalized 0-1) ---
        let state = {
            cameraInput: 0,
            tiltInput: 0,
            touchX: 0.5,
            touchY: 0.5
        };
        
        // Input Config Flags - Enabled by default
        let config = {
            useCamera: true,
            useTilt: true
        };

        // --- DOM ELEMENTS ---
        const video = document.getElementById('webcam');
        const visualizerCanvas = document.getElementById('visualizer');
        const mainScreen = document.getElementById('main-screen');
        const visCtx = visualizerCanvas.getContext('2d');
        const powerBtn = document.getElementById('power-btn');
        const holdBtn = document.getElementById('hold-btn');
        const touchPad = document.getElementById('touch-pad');
        const camValDisplay = document.getElementById('cam-val-display');
        const tiltValDisplay = document.getElementById('tilt-val-display');
        
        // Toggles
        const btnToggleCam = document.getElementById('btn-toggle-cam');
        const btnToggleTilt = document.getElementById('btn-toggle-tilt');
        const camControlsDiv = document.getElementById('cam-controls');
        const tiltControlsDiv = document.getElementById('tilt-controls');
        const sensorPermBtn = document.getElementById('sensor-perm-btn');
        
        // Mappings
        const mapCamera1 = document.getElementById('map-camera-1');
        const mapCamera2 = document.getElementById('map-camera-2');
        const mapTilt1 = document.getElementById('map-tilt-1');
        const mapTilt2 = document.getElementById('map-tilt-2');
        const mapTouchX1 = document.getElementById('map-touch-x-1');
        const mapTouchX2 = document.getElementById('map-touch-x-2');
        const mapTouchY1 = document.getElementById('map-touch-y-1');
        const mapTouchY2 = document.getElementById('map-touch-y-2');

        // Labels
        const lblXLow = document.getElementById('label-x-low');
        const lblXHigh = document.getElementById('label-x-high');
        const lblYLow = document.getElementById('label-y-low');
        const lblYHigh = document.getElementById('label-y-high');

        let animationId;
        let baseLightLevel = 128;
        
        // Static Soft Clip Curve
        function makeSoftClipCurve(amount) {
            let k = amount;
            let n_samples = 44100;
            let curve = new Float32Array(n_samples);
            let deg = Math.PI / 180;
            for (let i = 0; i < n_samples; ++i) {
                let x = i * 2 / n_samples - 1;
                // Soft clipping formula
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }

        function createReverbImpulse(duration) {
            const sampleRate = audioCtx.sampleRate;
            const length = sampleRate * duration;
            const impulse = audioCtx.createBuffer(2, length, sampleRate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);
            for (let i = 0; i < length; i++) {
                const decay = Math.pow(1 - i / length, 2); 
                left[i] = (Math.random() * 2 - 1) * decay;
                right[i] = (Math.random() * 2 - 1) * decay;
            }
            return impulse;
        }

        function initAudio() {
            if (audioCtx) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();

            oscillator = audioCtx.createOscillator();
            lfo = audioCtx.createOscillator();
            lfoGain = audioCtx.createGain(); 
            filterNode = audioCtx.createBiquadFilter();
            
            // Distortion Chain
            distGain = audioCtx.createGain();
            distNode = audioCtx.createWaveShaper();
            distNode.curve = makeSoftClipCurve(50); // Static curve
            distNode.oversample = '4x';
            
            gainNode = audioCtx.createGain(); 
            masterGainNode = audioCtx.createGain(); 
            analyser = audioCtx.createAnalyser();

            delayNode = audioCtx.createDelay(1.0);
            delayFeedback = audioCtx.createGain();
            delayDry = audioCtx.createGain();
            delayWet = audioCtx.createGain();
            reverbNode = audioCtx.createConvolver();
            reverbDry = audioCtx.createGain();
            reverbWet = audioCtx.createGain();
            
            oscillator.type = 'sine';
            gainNode.gain.value = 0; 
            masterGainNode.gain.value = parseFloat(document.getElementById('master-vol').value);
            filterNode.type = 'lowpass';
            filterNode.frequency.value = 1000;
            filterNode.Q.value = 5;
            lfo.type = 'sine';
            lfo.frequency.value = 3;
            lfoGain.gain.value = 0;
            
            // Initial drive (input gain to shaper)
            distGain.gain.value = 1.0; 

            reverbNode.buffer = createReverbImpulse(2.0);

            lfo.connect(lfoGain);
            
            // Chain: Osc -> DistGain -> DistNode -> Filter -> VCA
            oscillator.connect(distGain);
            distGain.connect(distNode);
            distNode.connect(filterNode); 
            filterNode.connect(gainNode);

            gainNode.connect(delayDry);
            gainNode.connect(delayNode);
            delayNode.connect(delayFeedback);
            delayFeedback.connect(delayNode); 
            delayNode.connect(delayWet);

            const postDelay = audioCtx.createGain();
            delayDry.connect(postDelay);
            delayWet.connect(postDelay);

            postDelay.connect(reverbDry);
            postDelay.connect(reverbNode);
            reverbNode.connect(reverbWet);
            
            reverbDry.connect(analyser);
            reverbWet.connect(analyser);

            analyser.connect(masterGainNode);
            masterGainNode.connect(audioCtx.destination);

            oscillator.start();
            lfo.start();

            analyser.fftSize = 2048;
            updateBaseParams();
        }

        function updateBaseParams() {
            if(!audioCtx) return;
            masterGainNode.gain.setTargetAtTime(parseFloat(document.getElementById('master-vol').value), audioCtx.currentTime, 0.05);
            
            const dTime = parseFloat(document.getElementById('delay-time').value);
            const dMix = parseFloat(document.getElementById('delay-mix').value);
            
            // Reverb Mix (Set base value, modulation can override)
            const rMix = parseFloat(document.getElementById('reverb-mix').value);
            
            delayNode.delayTime.setTargetAtTime(dTime, audioCtx.currentTime, 0.1);
            
            // Reverb check logic handled in applyModulations usually, but setting base is safe
            // We'll set it here, applyModulations will overwrite if active
            const mapsToReverb = [
                mapCamera1.value, mapCamera2.value,
                mapTilt1.value, mapTilt2.value,
                mapTouchX1.value, mapTouchX2.value,
                mapTouchY1.value, mapTouchY2.value
            ].includes('reverbMix');
            
            if(!mapsToReverb) {
                reverbDry.gain.setTargetAtTime(1 - rMix, audioCtx.currentTime, 0.1);
                reverbWet.gain.setTargetAtTime(rMix, audioCtx.currentTime, 0.1);
            }
            
            // Delay check logic
            const mapsToDelay = [
                mapCamera1.value, mapCamera2.value,
                mapTilt1.value, mapTilt2.value,
                mapTouchX1.value, mapTouchX2.value,
                mapTouchY1.value, mapTouchY2.value
            ].includes('delayMix');
            
            if(!mapsToDelay) {
                delayDry.gain.setTargetAtTime(1 - dMix, audioCtx.currentTime, 0.1);
                delayWet.gain.setTargetAtTime(dMix, audioCtx.currentTime, 0.1);
            }

            const target = document.getElementById('lfo-target').value;
            try { lfoGain.disconnect(); } catch(e){}
            if (target === 'pitch') lfoGain.connect(oscillator.frequency);
            else if (target === 'filter') lfoGain.connect(filterNode.frequency);
            
            // Static Drive Update
            const driveVal = parseFloat(document.getElementById('dist-drive').value);
            // Map 0-100 to 1-20x gain
            const gain = 1 + (driveVal / 100) * 20;
            distGain.gain.setTargetAtTime(gain, audioCtx.currentTime, 0.1);
        }

        // --- MODULATION & CORE LOGIC ---
        function applyModulations() {
            if (!audioCtx) return;

            // Targets Accumulators
            let targets = {
                pitch: { sum: 0, count: 0 },
                filter: { sum: 0, count: 0 },
                lfoRate: { sum: 0, count: 0 },
                lfoDepth: { sum: 0, count: 0 },
                resonance: { sum: 0, count: 0 },
                distortion: { sum: 0, count: 0 },
                reverbMix: { sum: 0, count: 0 },
                delayMix: { sum: 0, count: 0 }
            };

            // Helper to add contributions
            const addMod = (mapping, value) => {
                if (mapping !== 'none') {
                    targets[mapping].sum += value;
                    targets[mapping].count++;
                }
            };

            // Add Sources (If enabled)
            if (config.useCamera) {
                addMod(mapCamera1.value, state.cameraInput);
                addMod(mapCamera2.value, state.cameraInput);
            }
            if (config.useTilt) {
                addMod(mapTilt1.value, state.tiltInput);
                addMod(mapTilt2.value, state.tiltInput);
            }
            // Touch always active if present
            addMod(mapTouchX1.value, state.touchX);
            addMod(mapTouchX2.value, state.touchX);
            addMod(mapTouchY1.value, state.touchY);
            addMod(mapTouchY2.value, state.touchY);

            // Average
            let finalValues = {};
            for (let key in targets) {
                if (targets[key].count > 0) {
                    finalValues[key] = targets[key].sum / targets[key].count;
                } else {
                    finalValues[key] = null; 
                }
            }

            const now = audioCtx.currentTime;
            const rampTime = 0.1; // Slower ramp to prevent clicks

            // --- PITCH ---
            if (finalValues.pitch !== null) {
                // Range increased: 100Hz to 2000Hz (One octave higher max)
                const freq = 100 + Math.pow(finalValues.pitch, 2) * 1900; 
                oscillator.frequency.setTargetAtTime(freq, now, rampTime);
            }

            // --- FILTER ---
            let currentFilterFreq = parseFloat(document.getElementById('filter-cutoff').value);
            if (finalValues.filter !== null) {
                // Map 50Hz to 10000Hz (Clamped)
                let freq = 50 + Math.pow(finalValues.filter, 2) * 10000;
                // Hard Safety Clamp
                if (freq < 20) freq = 20;
                if (freq > 20000) freq = 20000;
                
                currentFilterFreq = freq;
                filterNode.frequency.setTargetAtTime(freq, now, rampTime);
            }

            // --- LFO RATE ---
            if (finalValues.lfoRate !== null) {
                const rate = 0.1 + (finalValues.lfoRate * 20);
                lfo.frequency.setTargetAtTime(rate, now, rampTime);
                document.getElementById('lfo-rate').value = rate; 
            } else {
                lfo.frequency.setTargetAtTime(parseFloat(document.getElementById('lfo-rate').value), now, rampTime);
            }

            // --- LFO DEPTH ---
            let currentDepth = parseFloat(document.getElementById('lfo-depth').value);
            if (finalValues.lfoDepth !== null) {
                currentDepth = finalValues.lfoDepth * 1000;
                document.getElementById('lfo-depth').value = currentDepth;
            } 
            
            // Safety clamp for Filter Target LFO
            const lfoTarget = document.getElementById('lfo-target').value;
            if(lfoTarget === 'filter') {
                // Prevent negative frequency: Depth must be < FilterFreq
                // We clamp modulation depth to 90% of current filter freq
                if(currentDepth > currentFilterFreq * 0.9) {
                    currentDepth = currentFilterFreq * 0.9;
                }
            }
            
            lfoGain.gain.setTargetAtTime(currentDepth, now, rampTime);

            // --- RESONANCE ---
            if (finalValues.resonance !== null) {
                const res = finalValues.resonance * 20;
                filterNode.Q.setTargetAtTime(res, now, rampTime);
                document.getElementById('filter-res').value = res;
            } else {
                filterNode.Q.setTargetAtTime(parseFloat(document.getElementById('filter-res').value), now, rampTime);
            }

            // --- DISTORTION ---
            if (finalValues.distortion !== null) {
                const driveMod = finalValues.distortion * 100; // 0-100 visual
                const gain = 1 + (finalValues.distortion * 20); // 1-21x
                distGain.gain.setTargetAtTime(gain, now, rampTime);
                document.getElementById('dist-drive').value = driveMod;
            }
            
            // --- REVERB MIX ---
            if (finalValues.reverbMix !== null) {
                const rMix = finalValues.reverbMix;
                reverbDry.gain.setTargetAtTime(1 - rMix, now, rampTime);
                reverbWet.gain.setTargetAtTime(rMix, now, rampTime);
                document.getElementById('reverb-mix').value = rMix;
            } else {
                // If not modulated, allow slider update (handled in updateBaseParams)
            }
            
            // --- DELAY MIX ---
            if (finalValues.delayMix !== null) {
                const dMix = finalValues.delayMix;
                delayDry.gain.setTargetAtTime(1 - dMix, now, rampTime);
                delayWet.gain.setTargetAtTime(dMix, now, rampTime);
                document.getElementById('delay-mix').value = dMix;
            } else {
                // If not modulated, allow slider update (handled in updateBaseParams)
            }
        }
        
        document.getElementById('dist-drive').addEventListener('input', (e) => {
             if (audioCtx) distNode.curve = makeDistortionCurve(parseFloat(e.target.value));
        });

        // --- ENVELOPES ---
        function triggerAttack() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            
            // Amp
            const atk = parseFloat(document.getElementById('atk').value);
            const dec = parseFloat(document.getElementById('dec').value);
            const sus = parseFloat(document.getElementById('sus').value);

            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setTargetAtTime(ENVELOPE_PEAK, now, atk / 3);
            gainNode.gain.setTargetAtTime(ENVELOPE_PEAK * sus, now + atk, dec / 3);
            
            // Filter (Only if not being modulated manually)
            // Check all 8 slots for 'filter'
            const maps = [
                mapCamera1.value, mapCamera2.value, 
                mapTilt1.value, mapTilt2.value,
                mapTouchX1.value, mapTouchX2.value,
                mapTouchY1.value, mapTouchY2.value
            ];
            const mapsToFilter = maps.includes('filter');
            
            if (!mapsToFilter) {
                const fAtk = parseFloat(document.getElementById('f-atk').value);
                const fDec = parseFloat(document.getElementById('f-dec').value);
                const fSus = parseFloat(document.getElementById('f-sus').value);
                const fAmt = parseFloat(document.getElementById('f-amt').value);
                const baseCutoff = parseFloat(document.getElementById('filter-cutoff').value);

                filterNode.frequency.cancelScheduledValues(now);
                
                const peakFreq = baseCutoff + fAmt;
                const susFreq = baseCutoff + (fAmt * fSus);
                
                const clampedPeak = peakFreq > 22000 ? 22000 : peakFreq;
                const clampedSus = susFreq > 22000 ? 22000 : susFreq;

                filterNode.frequency.setTargetAtTime(clampedPeak, now, fAtk / 3);
                filterNode.frequency.setTargetAtTime(clampedSus, now + fAtk, fDec / 3);
            }
        }

        function triggerRelease() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            
            const rel = parseFloat(document.getElementById('rel').value);
            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setTargetAtTime(0, now, rel / 5); 

            // Filter Release
            const maps = [
                mapCamera1.value, mapCamera2.value, 
                mapTilt1.value, mapTilt2.value,
                mapTouchX1.value, mapTouchX2.value,
                mapTouchY1.value, mapTouchY2.value
            ];
            const mapsToFilter = maps.includes('filter');
            if(!mapsToFilter) {
                const fRel = parseFloat(document.getElementById('f-rel').value);
                const baseCutoff = parseFloat(document.getElementById('filter-cutoff').value);
                filterNode.frequency.cancelScheduledValues(now);
                filterNode.frequency.setTargetAtTime(baseCutoff, now, fRel / 3);
            }
        }

        // --- INPUT HANDLING ---

        // Config Toggles
        function toggleInputConfig(type) {
            if(type === 'camera') {
                config.useCamera = !config.useCamera;
                btnToggleCam.classList.toggle('active');
                
                if(config.useCamera && isPlaying) startCamera();
                else stopCamera();
            }
            if(type === 'tilt') {
                config.useTilt = !config.useTilt;
                btnToggleTilt.classList.toggle('active');
                
                if(config.useTilt && isPlaying) {
                    window.addEventListener('deviceorientation', handleOrientation);
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        sensorPermBtn.classList.remove('hidden');
                    }
                } else {
                    window.removeEventListener('deviceorientation', handleOrientation);
                }
            }
        }
        
        btnToggleCam.onclick = () => toggleInputConfig('camera');
        btnToggleTilt.onclick = () => toggleInputConfig('tilt');

        // 1. Gyro Logic
        function handleOrientation(event) {
            if (!config.useTilt || !isPlaying) return;
            
            let pitch = event.beta; 
            if (pitch === null) return;
            if (pitch < 0) pitch = 0;
            if (pitch > 80) pitch = 80;

            const sensitivity = parseFloat(document.getElementById('tilt-sensitivity').value);
            let normalized = pitch / 80;
            normalized = Math.pow(normalized, 1/sensitivity);

            state.tiltInput = normalized;
            tiltValDisplay.innerText = `TILT: ${Math.round(normalized*100)}%`;
            applyModulations();
        }

        // 2. Camera Logic
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user", width: 320, height: 240 } });
                video.srcObject = stream;
                video.play();
                video.classList.remove('hidden');
                camValDisplay.classList.remove('hidden');
            } catch (err) {
                // If camera fails, fail gracefully but keep app running
                console.error(err);
                camValDisplay.innerText = "CAM ERR";
                camValDisplay.classList.remove('hidden');
            }
        }
        function stopCamera() {
            if(!video.srcObject) return;
            video.srcObject.getTracks().forEach(t => t.stop());
            video.srcObject = null;
            video.classList.add('hidden');
            camValDisplay.classList.add('hidden');
        }

        const processingCanvas = document.createElement('canvas');
        const procCtx = processingCanvas.getContext('2d');
        
        function processCameraFrame() {
            const w = 32; const h = 32;
            processingCanvas.width = w; processingCanvas.height = h;
            procCtx.translate(w, 0); procCtx.scale(-1, 1);
            procCtx.drawImage(video, 0, 0, w, h);
            procCtx.setTransform(1, 0, 0, 1, 0, 0);
            
            const data = procCtx.getImageData(0, 0, w, h).data;
            let total = 0;
            for (let i = 0; i < data.length; i += 16) { 
                total += (0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
            }
            let avg = total / (data.length / 16); 
            if (avg > baseLightLevel) avg = baseLightLevel;
            
            const sens = document.getElementById('sensitivity').value / 50; 
            let normalized = (1 - (avg / baseLightLevel)) * sens;
            if(normalized > 1) normalized = 1; if(normalized<0) normalized=0;

            state.cameraInput = normalized;
            camValDisplay.innerText = `CAM: ${Math.round(normalized*100)}%`;
            applyModulations();
        }

        // 3. Touch Logic
        function handleTouch(x, y, width, height) {
            if (!audioCtx) return;
            const xPercent = x / width;
            const yPercent = 1 - (y / height); // Invert Y so top is 1

            state.touchX = xPercent;
            state.touchY = yPercent;
            applyModulations();
        }

        // --- LOOPS & EVENTS ---
        function loop() {
            animationId = requestAnimationFrame(loop);
            drawVisualizer();
            if (config.useCamera && video.readyState === video.HAVE_ENOUGH_DATA && isPlaying) {
                processCameraFrame();
            }
        }

        function drawVisualizer() {
            if (!analyser) return;
            const len = analyser.frequencyBinCount;
            const data = new Uint8Array(len);
            analyser.getByteTimeDomainData(data);
            const w = visualizerCanvas.width = visualizerCanvas.clientWidth;
            const h = visualizerCanvas.height = visualizerCanvas.clientHeight;
            visCtx.clearRect(0,0,w,h);
            visCtx.lineWidth=2; visCtx.strokeStyle='#4fd1c5';
            visCtx.beginPath();
            let slice = w * 1.0 / len; let x = 0;
            for(let i=0; i<len; i++) {
                let v = data[i] / 128.0; let y = v * h/2;
                if(i===0) visCtx.moveTo(x,y); else visCtx.lineTo(x,y);
                x+=slice;
            }
            visCtx.lineTo(w, h/2); visCtx.stroke();
        }

        // --- UI BINDINGS ---
        
        function updatePadLabels() {
            const mapX = mapTouchX1.value; // Using Slot 1 as primary label source
            const mapY = mapTouchY1.value;

            const labels = {
                'pitch': ['Low Pitch', 'High Pitch'],
                'filter': ['Dark', 'Bright'],
                'lfoRate': ['Slow', 'Fast'],
                'lfoDepth': ['Flat', 'Wobbly'],
                'resonance': ['Soft', 'Sharp'],
                'distortion': ['Clean', 'Crunchy'],
                'reverbMix': ['Dry', 'Wet'],
                'delayMix': ['Dry', 'Wet'],
                'none': ['', '']
            };

            lblXLow.innerText = labels[mapX][0];
            lblXHigh.innerText = labels[mapX][1];
            lblYHigh.innerText = labels[mapY][1]; 
            lblYLow.innerText = labels[mapY][0];
        }

        // Update labels on any mapping change
        const mapSelects = [
            mapCamera1, mapCamera2, mapTilt1, mapTilt2, 
            mapTouchX1, mapTouchX2, mapTouchY1, mapTouchY2
        ];
        
        mapSelects.forEach(el => el.addEventListener('change', () => {
            updatePadLabels();
            applyModulations();
        }));
        updatePadLabels();

        // Touch Listeners
        let isTouching = false;
        const startT = (e) => { 
            e.preventDefault(); if(!isPlaying) return;
            isTouching = true; if(!isHoldActive) triggerAttack();
            const r = touchPad.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            handleTouch(clientX - r.left, clientY - r.top, r.width, r.height);
        };
        const moveT = (e) => {
            e.preventDefault(); if(!isTouching) return;
            const r = touchPad.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            handleTouch(clientX - r.left, clientY - r.top, r.width, r.height);
        };
        const endT = (e) => {
            if(e) e.preventDefault();
            isTouching = false; if(isPlaying && !isHoldActive) triggerRelease();
        };

        touchPad.addEventListener('mousedown', startT);
        touchPad.addEventListener('mousemove', moveT);
        touchPad.addEventListener('mouseup', endT);
        touchPad.addEventListener('mouseleave', endT);
        touchPad.addEventListener('touchstart', startT, {passive:false});
        touchPad.addEventListener('touchmove', moveT, {passive:false});
        touchPad.addEventListener('touchend', endT);

        // System Start/Stop
        powerBtn.onclick = () => {
            if (!isPlaying) {
                initAudio(); audioCtx.resume(); isPlaying = true;
                document.getElementById('status-indicator').classList.remove('hidden');
                
                // Initialize active configs
                if(config.useCamera) startCamera(); 
                if(config.useTilt) {
                    window.addEventListener('deviceorientation', handleOrientation);
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        sensorPermBtn.classList.remove('hidden');
                    }
                    tiltValDisplay.classList.remove('hidden');
                }

                powerBtn.innerText = "STOP SYSTEM";
                powerBtn.classList.replace('bg-red-500','bg-green-500');
                loop();
            } else {
                isPlaying = false; triggerRelease(); stopCamera();
                window.removeEventListener('deviceorientation', handleOrientation);
                document.getElementById('status-indicator').classList.add('hidden');
                powerBtn.innerText = "START SYSTEM";
                powerBtn.classList.replace('bg-green-500','bg-red-500');
                cancelAnimationFrame(animationId);
                isHoldActive = false;
                holdBtn.classList.remove('hold-active');
                mainScreen.classList.remove('screen-hold-active');
            }
        };

        holdBtn.onclick = () => {
            if(!isPlaying) powerBtn.click();
            isHoldActive = !isHoldActive;
            if(isHoldActive) {
                holdBtn.classList.add('hold-active');
                mainScreen.classList.add('screen-hold-active');
                triggerAttack();
            } else {
                holdBtn.classList.remove('hold-active');
                mainScreen.classList.remove('screen-hold-active');
                if(!isTouching) triggerRelease();
            }
        };

        // Calibrate
        document.getElementById('calibrate-btn').onclick = () => {
             if(config.useCamera && isPlaying) {
                 baseLightLevel = 255; 
             }
        };
        
        // Sensor Perms
        sensorPermBtn.onclick = () => {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(r => {
                    if(r==='granted') { window.addEventListener('deviceorientation', handleOrientation); sensorPermBtn.classList.add('hidden');}
                });
            }
        };

        // Params listeners: ADDED LFO AND CUTOFF HERE
        const paramIds = ['master-vol', 'delay-time', 'delay-mix', 'reverb-mix', 'lfo-target', 'lfo-rate', 'lfo-depth', 'filter-cutoff', 'filter-res', 'dist-drive'];
        
        // Use applyModulations for instantaneous feedback on slider change as well
        paramIds.forEach(id => document.getElementById(id).addEventListener('input', () => {
            updateBaseParams();
            applyModulations();
        }));

        document.querySelectorAll('.wave-btn').forEach(btn => {
            btn.onclick = (e) => {
                if(oscillator) oscillator.type = e.target.dataset.type;
                document.querySelectorAll('.wave-btn').forEach(b => b.classList.remove('bg-teal-600', 'border-teal-400'));
                e.target.classList.add('bg-teal-600', 'border-teal-400');
                document.getElementById('current-wave').innerText = `Current: ${oscillator.type}`;
            };
        });
        document.querySelector('[data-type="sine"]').classList.add('bg-teal-600', 'border-teal-400');

    </script>
</body>
</html>
