<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lumina Motion Synth</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4fd1c5;
            margin-top: -8px;
            box-shadow: 0 0 10px rgba(79, 209, 197, 0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #2d3748;
            border-radius: 2px;
        }
        input[type=range]:focus {
            outline: none;
        }
        
        /* CRT/Glow Effects */
        .glow-text {
            text-shadow: 0 0 5px #4fd1c5, 0 0 10px #4fd1c5;
        }
        .screen-container {
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
            border: 1px solid #333;
        }

        /* Prevent scrolling on touch */
        body {
            overscroll-behavior: none;
            touch-action: manipulation;
        }
        
        .control-group {
            background: rgba(26, 32, 44, 0.8);
            border: 1px solid #2d3748;
            border-radius: 0.5rem;
            padding: 0.75rem;
        }

        /* Active state for touch pad */
        #touch-pad:active {
            background: rgba(79, 209, 197, 0.1);
            border-color: #4fd1c5;
        }

        .vertical-range-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* Hold Button Active State */
        .hold-active {
            background-color: #4fd1c5 !important;
            color: #1a202c !important;
            box-shadow: 0 0 15px rgba(79, 209, 197, 0.6);
            border-color: #fff !important;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-300 font-sans h-screen flex flex-col overflow-hidden">

    <!-- Header & Mode Switch -->
    <header class="flex-none p-3 border-b border-gray-800 flex justify-between items-center bg-gray-900 z-10">
        <h1 class="text-xl font-bold text-teal-400 tracking-wider">LUMINA <span class="text-xs text-gray-500 font-normal">HYBRID</span></h1>
        
        <div class="flex items-center gap-2">
            <span class="text-[10px] text-teal-600 animate-pulse hidden" id="status-indicator">‚óè LIVE</span>
        </div>
        
        <button id="power-btn" class="bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-4 rounded shadow-[0_0_10px_rgba(239,68,68,0.5)] transition-colors">
            START SYSTEM
        </button>
    </header>

    <!-- Main Visual Area -->
    <div class="flex-none relative h-48 bg-black screen-container w-full overflow-hidden">
        <!-- Visualizer Canvas -->
        <canvas id="visualizer" class="absolute top-0 left-0 w-full h-full z-10 opacity-80 pointer-events-none"></canvas>
        
        <!-- Video Element for Input (Always active when on) -->
        <video id="webcam" class="absolute top-0 left-0 w-full h-full object-cover opacity-30 z-0 hidden" playsinline muted></video>
        
        <!-- Touch Surface Overlay -->
        <div id="touch-pad" class="absolute top-0 left-0 w-full h-full z-20 cursor-crosshair flex flex-col items-center justify-center p-4">
            <span class="pointer-events-none text-gray-400 text-xs select-none opacity-60 font-bold mb-1 bg-black/50 px-2 rounded" id="pad-hint">
                Touch to Play | X: Filter | Y: LFO
            </span>
            
            <!-- Axis Labels -->
            <div class="pointer-events-none text-[10px] text-teal-500 opacity-60 flex justify-between w-full absolute bottom-2 px-4 font-mono">
                <span>Filter Low</span>
                <span>Filter High</span>
            </div>
            <div class="pointer-events-none text-[10px] text-teal-500 opacity-60 flex flex-col justify-between h-full absolute right-2 py-4 items-end font-mono">
                <span>Fast LFO</span>
                <span>Slow LFO</span>
            </div>
        </div>

        <!-- Feedback Overlay -->
        <div id="cam-feedback" class="absolute top-2 right-2 z-30 bg-black/60 px-2 py-1 rounded text-xs text-teal-300 hidden font-mono border border-teal-900">
            CAM PITCH: <span id="light-val">0</span>%
        </div>
    </div>

    <!-- Controls Container -->
    <main class="flex-1 overflow-y-auto p-4 space-y-4 pb-20">
        
        <!-- Global Controls (Volume & Hold) -->
        <div class="control-group flex items-center justify-between gap-4 bg-gray-800/50">
            <div class="flex-1">
                <label class="text-[10px] font-bold text-teal-500 uppercase block mb-1">Master Volume</label>
                <input type="range" id="master-vol" min="0" max="1" step="0.01" value="0.5">
            </div>
            <div class="flex-none">
                <button id="hold-btn" class="border-2 border-teal-600 text-teal-500 text-xs font-bold py-2 px-4 rounded transition-all">
                    HOLD NOTE
                </button>
            </div>
        </div>

        <!-- Input Sensitivity (Camera) -->
        <div class="control-group border-teal-900/50">
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-xs font-bold text-teal-500 uppercase">Camera Pitch Sensitivity</h3>
                <span class="text-[10px] text-teal-600">Selfie Cam</span>
            </div>
            <input type="range" id="sensitivity" min="0" max="100" value="50" class="mb-1">
            <div class="flex justify-between text-[10px] text-gray-500">
                <span>Low Sensitivity</span>
                <span>High Sensitivity</span>
            </div>
            <p class="text-[10px] text-gray-500 mt-1">Move hand closer (darker) for higher pitch.</p>
        </div>

        <!-- Main Parameters (Oscillator) -->
        <div class="control-group">
            <h3 class="text-xs font-bold text-teal-500 uppercase mb-3">Oscillator</h3>
            <div class="flex gap-2 mb-2 justify-between">
                <button class="wave-btn flex-1 py-2 bg-gray-700 rounded text-xs active:bg-teal-600 border border-gray-600" data-type="sine">Sine</button>
                <button class="wave-btn flex-1 py-2 bg-gray-700 rounded text-xs active:bg-teal-600 border border-gray-600" data-type="sawtooth">Saw</button>
                <button class="wave-btn flex-1 py-2 bg-gray-700 rounded text-xs active:bg-teal-600 border border-gray-600" data-type="square">Sqr</button>
                <button class="wave-btn flex-1 py-2 bg-gray-700 rounded text-xs active:bg-teal-600 border border-gray-600" data-type="triangle">Tri</button>
            </div>
            <div class="text-center text-xs text-teal-300" id="current-wave">Current: Sine</div>
        </div>

        <!-- Filter & Filter Envelope -->
        <div class="control-group">
            <h3 class="text-xs font-bold text-teal-500 uppercase mb-3">Filter & Envelope</h3>
            <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-xs font-bold mb-1">Base Cutoff</label>
                    <input type="range" id="filter-cutoff" min="50" max="5000" value="1000">
                </div>
                <div>
                    <label class="block text-xs font-bold mb-1">Resonance</label>
                    <input type="range" id="filter-res" min="0" max="20" value="5">
                </div>
            </div>
            
            <div class="border-t border-gray-700 pt-3">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-[10px] text-gray-400 uppercase">Filter Env ADSR</span>
                    <div class="w-1/3">
                         <label class="text-[10px] font-bold block text-right">Env Amount</label>
                         <input type="range" id="f-amt" min="0" max="5000" value="2000">
                    </div>
                </div>
                <div class="grid grid-cols-4 gap-2 text-center">
                    <div class="vertical-range-container">
                        <input type="range" id="f-atk" min="0.01" max="2" step="0.01" value="0.1" class="h-20 writing-mode-vertical appearance-none" style="-webkit-appearance: slider-vertical;">
                        <span class="block text-[10px] mt-1">A</span>
                    </div>
                    <div class="vertical-range-container">
                        <input type="range" id="f-dec" min="0.01" max="2" step="0.01" value="0.3" class="h-20 writing-mode-vertical" style="-webkit-appearance: slider-vertical;">
                        <span class="block text-[10px] mt-1">D</span>
                    </div>
                    <div class="vertical-range-container">
                        <input type="range" id="f-sus" min="0" max="1" step="0.01" value="0.5" class="h-20 writing-mode-vertical" style="-webkit-appearance: slider-vertical;">
                        <span class="block text-[10px] mt-1">S</span>
                    </div>
                    <div class="vertical-range-container">
                        <input type="range" id="f-rel" min="0.01" max="3" step="0.01" value="1.0" class="h-20 writing-mode-vertical" style="-webkit-appearance: slider-vertical;">
                        <span class="block text-[10px] mt-1">R</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Amp Envelope (ADSR) -->
        <div class="control-group">
            <h3 class="text-xs font-bold text-teal-500 uppercase mb-2">Amp Envelope</h3>
            <div class="grid grid-cols-4 gap-2 text-center">
                <div class="vertical-range-container">
                    <input type="range" id="atk" min="0.01" max="2" step="0.01" value="0.05" class="h-20 writing-mode-vertical appearance-none" style="-webkit-appearance: slider-vertical;">
                    <span class="block text-[10px] mt-1">A</span>
                </div>
                <div class="vertical-range-container">
                    <input type="range" id="dec" min="0.01" max="2" step="0.01" value="0.2" class="h-20 writing-mode-vertical" style="-webkit-appearance: slider-vertical;">
                    <span class="block text-[10px] mt-1">D</span>
                </div>
                <div class="vertical-range-container">
                    <input type="range" id="sus" min="0" max="1" step="0.01" value="0.8" class="h-20 writing-mode-vertical" style="-webkit-appearance: slider-vertical;">
                    <span class="block text-[10px] mt-1">S</span>
                </div>
                <div class="vertical-range-container">
                    <input type="range" id="rel" min="0.01" max="3" step="0.01" value="0.5" class="h-20 writing-mode-vertical" style="-webkit-appearance: slider-vertical;">
                    <span class="block text-[10px] mt-1">R</span>
                </div>
            </div>
        </div>

        <!-- Effects (Delay & Reverb) -->
        <div class="control-group">
            <h3 class="text-xs font-bold text-teal-500 uppercase mb-3">Effects</h3>
            
            <!-- Delay -->
            <div class="mb-4">
                <h4 class="text-[10px] text-gray-400 uppercase mb-2">Delay</h4>
                <div class="grid grid-cols-3 gap-2">
                    <div>
                        <label class="block text-[10px] mb-1">Time</label>
                        <input type="range" id="delay-time" min="0" max="1" step="0.01" value="0.3">
                    </div>
                    <div>
                        <label class="block text-[10px] mb-1">Fdbk</label>
                        <input type="range" id="delay-feedback" min="0" max="0.9" step="0.01" value="0.4">
                    </div>
                    <div>
                        <label class="block text-[10px] mb-1">Mix</label>
                        <input type="range" id="delay-mix" min="0" max="1" step="0.01" value="0.3">
                    </div>
                </div>
            </div>

            <!-- Reverb -->
            <div>
                <h4 class="text-[10px] text-gray-400 uppercase mb-2">Reverb</h4>
                <div class="grid grid-cols-1 gap-2">
                    <div>
                        <label class="block text-[10px] mb-1">Mix</label>
                        <input type="range" id="reverb-mix" min="0" max="1" step="0.01" value="0.3">
                    </div>
                </div>
            </div>
        </div>

        <!-- LFO -->
        <div class="control-group">
            <div class="flex justify-between mb-2">
                <h3 class="text-xs font-bold text-teal-500 uppercase">LFO</h3>
                <select id="lfo-target" class="bg-gray-800 text-xs border border-gray-600 rounded px-1">
                    <option value="pitch">Pitch</option>
                    <option value="filter">Filter</option>
                    <option value="none">Off</option>
                </select>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-xs font-bold mb-1">Rate</label>
                    <input type="range" id="lfo-rate" min="0.1" max="20" step="0.1" value="3">
                </div>
                <div>
                    <label class="block text-xs font-bold mb-1">Depth</label>
                    <input type="range" id="lfo-depth" min="0" max="1000" value="100">
                </div>
            </div>
            <p class="text-[10px] text-gray-500 mt-2">Note: Touch Y-axis also overrides Rate.</p>
        </div>

    </main>

    <script>
        // --- AUDIO ENGINE CONTEXT ---
        let audioCtx;
        let oscillator;
        let gainNode; // VCA (Envelope)
        let masterGainNode; // Final Volume Control
        let filterNode;
        let lfo;
        let lfoGain;
        let analyser;
        
        // Effects Nodes
        let delayNode, delayFeedback, delayDry, delayWet;
        let reverbNode, reverbDry, reverbWet;

        let isPlaying = false;
        let isHoldActive = false; // Hold State
        
        // Envelopes peak at 0.8 to leave headroom, Master Volume scales the result
        const ENVELOPE_PEAK = 0.8; 

        // --- CAMERA & DOM ELEMENTS ---
        const video = document.getElementById('webcam');
        const visualizerCanvas = document.getElementById('visualizer');
        const visCtx = visualizerCanvas.getContext('2d');
        const powerBtn = document.getElementById('power-btn');
        const holdBtn = document.getElementById('hold-btn');
        const touchPad = document.getElementById('touch-pad');
        const lightValDisplay = document.getElementById('light-val');
        const feedbackOverlay = document.getElementById('cam-feedback');
        const statusIndicator = document.getElementById('status-indicator');
        
        // --- STATE ---
        let animationId;
        let lastFrequency = 440; // For smoothing
        
        // --- REVERB IMPULSE GENERATOR ---
        function createReverbImpulse(duration) {
            const sampleRate = audioCtx.sampleRate;
            const length = sampleRate * duration;
            const impulse = audioCtx.createBuffer(2, length, sampleRate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                const decay = Math.pow(1 - i / length, 2); 
                left[i] = (Math.random() * 2 - 1) * decay;
                right[i] = (Math.random() * 2 - 1) * decay;
            }
            return impulse;
        }

        // --- AUDIO SETUP ---
        function initAudio() {
            if (audioCtx) return;
            
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();

            // 1. Create Source Nodes
            oscillator = audioCtx.createOscillator();
            lfo = audioCtx.createOscillator();
            lfoGain = audioCtx.createGain(); 
            
            // 2. Create Chain Nodes
            filterNode = audioCtx.createBiquadFilter();
            gainNode = audioCtx.createGain(); // Envelope VCA
            masterGainNode = audioCtx.createGain(); // Master Volume
            analyser = audioCtx.createAnalyser();

            // 3. Create Effects Nodes
            delayNode = audioCtx.createDelay(1.0);
            delayFeedback = audioCtx.createGain();
            delayDry = audioCtx.createGain();
            delayWet = audioCtx.createGain();
            
            reverbNode = audioCtx.createConvolver();
            reverbDry = audioCtx.createGain();
            reverbWet = audioCtx.createGain();
            
            // Init Settings
            oscillator.type = 'sine';
            gainNode.gain.value = 0; // Start silent
            
            // Set Master Volume from slider
            masterGainNode.gain.value = parseFloat(document.getElementById('master-vol').value);
            
            filterNode.type = 'lowpass';
            filterNode.frequency.value = 1000;
            filterNode.Q.value = 5;

            lfo.type = 'sine';
            lfo.frequency.value = 3;
            lfoGain.gain.value = 0;

            reverbNode.buffer = createReverbImpulse(2.0);

            // --- ROUTING ---
            
            lfo.connect(lfoGain);

            // Osc -> Filter -> VCA (Envelope)
            oscillator.connect(filterNode);
            filterNode.connect(gainNode);

            // VCA -> Delay Section
            gainNode.connect(delayDry);
            gainNode.connect(delayNode);
            
            delayNode.connect(delayFeedback);
            delayFeedback.connect(delayNode); 
            delayNode.connect(delayWet);

            const postDelay = audioCtx.createGain();
            delayDry.connect(postDelay);
            delayWet.connect(postDelay);

            // Delay -> Reverb Section
            postDelay.connect(reverbDry);
            postDelay.connect(reverbNode);
            
            reverbNode.connect(reverbWet);
            
            // Reverb -> Analyser
            reverbDry.connect(analyser);
            reverbWet.connect(analyser);

            // Analyser -> Master Volume -> Speakers
            analyser.connect(masterGainNode);
            masterGainNode.connect(audioCtx.destination);

            // Start sources
            oscillator.start();
            lfo.start();

            analyser.fftSize = 2048;

            updateParams();
        }

        function updateParams() {
            if(!audioCtx) return;

            // Master Volume
            masterGainNode.gain.setTargetAtTime(
                parseFloat(document.getElementById('master-vol').value), 
                audioCtx.currentTime, 
                0.05
            );

            // Filter
            const cutoff = parseFloat(document.getElementById('filter-cutoff').value);
            const res = parseFloat(document.getElementById('filter-res').value);
            filterNode.Q.value = res;

            // LFO
            const lfoRate = parseFloat(document.getElementById('lfo-rate').value);
            const depth = parseFloat(document.getElementById('lfo-depth').value);
            const target = document.getElementById('lfo-target').value;

            if(!isTouching) {
                 lfo.frequency.setTargetAtTime(lfoRate, audioCtx.currentTime, 0.1);
            }
           
            lfoGain.gain.setTargetAtTime(depth, audioCtx.currentTime, 0.1);

            try { lfoGain.disconnect(); } catch(e){}
            if (target === 'pitch') {
                lfoGain.connect(oscillator.frequency);
            } else if (target === 'filter') {
                lfoGain.connect(filterNode.frequency);
            }

            // Effects
            const dTime = parseFloat(document.getElementById('delay-time').value);
            const dFdbk = parseFloat(document.getElementById('delay-feedback').value);
            const dMix = parseFloat(document.getElementById('delay-mix').value);
            const rMix = parseFloat(document.getElementById('reverb-mix').value);

            delayNode.delayTime.setTargetAtTime(dTime, audioCtx.currentTime, 0.1);
            delayFeedback.gain.setTargetAtTime(dFdbk, audioCtx.currentTime, 0.1);
            delayDry.gain.setTargetAtTime(1 - dMix, audioCtx.currentTime, 0.1);
            delayWet.gain.setTargetAtTime(dMix, audioCtx.currentTime, 0.1);
            
            reverbDry.gain.setTargetAtTime(1 - rMix, audioCtx.currentTime, 0.1);
            reverbWet.gain.setTargetAtTime(rMix, audioCtx.currentTime, 0.1);
        }

        function triggerAttack() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;

            // --- AMP ENVELOPE ---
            const atk = parseFloat(document.getElementById('atk').value);
            const dec = parseFloat(document.getElementById('dec').value);
            const sus = parseFloat(document.getElementById('sus').value);

            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setValueAtTime(gainNode.gain.value, now);
            gainNode.gain.linearRampToValueAtTime(ENVELOPE_PEAK, now + atk);
            gainNode.gain.exponentialRampToValueAtTime(ENVELOPE_PEAK * sus + 0.001, now + atk + dec);

            // --- FILTER ENVELOPE ---
            const fAtk = parseFloat(document.getElementById('f-atk').value);
            const fDec = parseFloat(document.getElementById('f-dec').value);
            const fSus = parseFloat(document.getElementById('f-sus').value);
            const fAmt = parseFloat(document.getElementById('f-amt').value);
            const baseCutoff = parseFloat(document.getElementById('filter-cutoff').value);

            filterNode.frequency.cancelScheduledValues(now);
            filterNode.frequency.setValueAtTime(baseCutoff, now);
            
            const peakFreq = baseCutoff + fAmt;
            const clampedPeak = peakFreq > 22000 ? 22000 : peakFreq;
            
            filterNode.frequency.linearRampToValueAtTime(clampedPeak, now + fAtk);
            
            const sustainFreq = baseCutoff + (fAmt * fSus);
            const clampedSustain = sustainFreq > 22000 ? 22000 : sustainFreq;

            filterNode.frequency.exponentialRampToValueAtTime(clampedSustain, now + fAtk + fDec);
        }

        function triggerRelease() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const rel = parseFloat(document.getElementById('rel').value);
            
            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setValueAtTime(gainNode.gain.value, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + rel);
            gainNode.gain.linearRampToValueAtTime(0, now + rel + 0.05);
        }

        // --- CAMERA LOGIC ---
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: "user",
                        width: { ideal: 320 },
                        height: { ideal: 240 }
                    } 
                });
                video.srcObject = stream;
                video.play();
                video.classList.remove('hidden');
                feedbackOverlay.classList.remove('hidden');
                statusIndicator.classList.remove('hidden');
            } catch (err) {
                console.error("Camera failed", err);
                alert("Camera access issue: " + err.message);
            }
        }

        function stopCamera() {
            if(!video.srcObject) return;
            const stream = video.srcObject;
            const tracks = stream.getTracks();
            tracks.forEach(track => track.stop());
            video.srcObject = null;
            video.classList.add('hidden');
            feedbackOverlay.classList.add('hidden');
            statusIndicator.classList.add('hidden');
        }

        // --- PROCESSING LOOP ---
        const processingCanvas = document.createElement('canvas');
        const procCtx = processingCanvas.getContext('2d');

        function loop() {
            animationId = requestAnimationFrame(loop);
            drawVisualizer();
            if (video.readyState === video.HAVE_ENOUGH_DATA && isPlaying) {
                processCameraFrame();
            }
        }

        function processCameraFrame() {
            const w = 32; 
            const h = 32;
            processingCanvas.width = w;
            processingCanvas.height = h;
            
            procCtx.translate(w, 0);
            procCtx.scale(-1, 1);
            procCtx.drawImage(video, 0, 0, w, h);
            procCtx.setTransform(1, 0, 0, 1, 0, 0);
            
            const frame = procCtx.getImageData(0, 0, w, h);
            const data = frame.data;
            let totalBrightness = 0;
            
            for (let i = 0; i < data.length; i += 16) { 
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                totalBrightness += (0.299 * r + 0.587 * g + 0.114 * b);
            }

            const avgBrightness = totalBrightness / (data.length / 16); 
            const sens = document.getElementById('sensitivity').value / 50; 
            let normalized = (avgBrightness / 255);
            
            lightValDisplay.innerText = Math.round(normalized * 100);

            const minFreq = 100;
            const maxFreq = 1200;
            
            let targetFreq = maxFreq - (normalized * (maxFreq - minFreq) * sens);
            
            if (targetFreq < 50) targetFreq = 50;
            if (targetFreq > 2000) targetFreq = 2000;

            lastFrequency = lastFrequency + (targetFreq - lastFrequency) * 0.1;

            if (audioCtx) {
                oscillator.frequency.setTargetAtTime(lastFrequency, audioCtx.currentTime, 0.05);
            }
        }

        function drawVisualizer() {
            if (!analyser) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);

            const width = visualizerCanvas.width = visualizerCanvas.clientWidth;
            const height = visualizerCanvas.height = visualizerCanvas.clientHeight;

            visCtx.clearRect(0, 0, width, height);
            visCtx.lineWidth = 2;
            visCtx.strokeStyle = 'rgb(79, 209, 197)';
            visCtx.beginPath();

            const sliceWidth = width * 1.0 / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * height / 2;

                if (i === 0) {
                    visCtx.moveTo(x, y);
                } else {
                    visCtx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            visCtx.lineTo(width, height / 2);
            visCtx.stroke();
        }

        // --- INTERACTION HANDLERS ---
        
        // Power Button
        powerBtn.addEventListener('click', () => {
            if (!isPlaying) {
                initAudio();
                audioCtx.resume();
                isPlaying = true;
                startCamera();
                powerBtn.innerText = "STOP SYSTEM";
                powerBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                powerBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                
                // Note: We do NOT trigger attack here by default anymore.
                // User must touch pad or click Hold.
                
                loop();
            } else {
                isPlaying = false;
                triggerRelease();
                stopCamera();
                powerBtn.innerText = "START SYSTEM";
                powerBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                powerBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                cancelAnimationFrame(animationId);
                
                // Reset Hold
                isHoldActive = false;
                holdBtn.classList.remove('hold-active');
            }
        });

        // Hold Button Logic
        holdBtn.addEventListener('click', () => {
            if (!isPlaying) return;
            
            isHoldActive = !isHoldActive;
            
            if (isHoldActive) {
                holdBtn.classList.add('hold-active');
                triggerAttack(); // Start Drone
            } else {
                holdBtn.classList.remove('hold-active');
                if (!isTouching) {
                    triggerRelease(); // Stop Drone (unless touching)
                }
            }
        });

        // --- TOUCH LOGIC (Gate + Modulation) ---
        let isTouching = false;

        function handleTouch(x, y, width, height) {
            if (!audioCtx) return;
            
            const xPercent = x / width;
            const cutoffFreq = 50 + Math.pow(xPercent, 2) * 5000;
            
            const yPercent = 1 - (y / height);
            const lfoRate = 0.1 + (yPercent * 20); 

            filterNode.frequency.setTargetAtTime(cutoffFreq, audioCtx.currentTime, 0.05);
            lfo.frequency.setTargetAtTime(lfoRate, audioCtx.currentTime, 0.05);
            
            document.getElementById('filter-cutoff').value = cutoffFreq;
            document.getElementById('lfo-rate').value = lfoRate;
        }

        // Mouse Events
        touchPad.addEventListener('mousedown', (e) => {
            if (!isPlaying) return;
            isTouching = true;
            if (!isHoldActive) triggerAttack();
            handleTouch(e.offsetX, e.offsetY, touchPad.clientWidth, touchPad.clientHeight);
        });

        touchPad.addEventListener('mousemove', (e) => {
            if (!isTouching) return;
            handleTouch(e.offsetX, e.offsetY, touchPad.clientWidth, touchPad.clientHeight);
        });

        const stopTouch = () => {
            isTouching = false;
            if (isPlaying && !isHoldActive) triggerRelease();
        };

        touchPad.addEventListener('mouseup', stopTouch);
        touchPad.addEventListener('mouseleave', stopTouch);

        // Touch Events
        touchPad.addEventListener('touchstart', (e) => {
            if (!isPlaying) return;
            e.preventDefault();
            isTouching = true;
            if (!isHoldActive) triggerAttack();
            const rect = touchPad.getBoundingClientRect();
            handleTouch(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top, rect.width, rect.height);
        }, {passive: false});

        touchPad.addEventListener('touchmove', (e) => {
            if (!isTouching) return;
            e.preventDefault();
            const rect = touchPad.getBoundingClientRect();
            handleTouch(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top, rect.width, rect.height);
        }, {passive: false});

        touchPad.addEventListener('touchend', stopTouch);

        // UI Listeners
        document.querySelectorAll('.wave-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const type = e.target.dataset.type;
                if(oscillator) oscillator.type = type;
                document.querySelectorAll('.wave-btn').forEach(b => b.classList.remove('bg-teal-600', 'border-teal-400'));
                e.target.classList.add('bg-teal-600', 'border-teal-400');
                document.getElementById('current-wave').innerText = `Current: ${type.charAt(0).toUpperCase() + type.slice(1)}`;
            });
        });

        document.querySelector('[data-type="sine"]').classList.add('bg-teal-600', 'border-teal-400');

        const paramIds = [
            'filter-cutoff', 'filter-res', 
            'lfo-rate', 'lfo-depth', 'lfo-target',
            'delay-time', 'delay-feedback', 'delay-mix',
            'reverb-mix', 'master-vol'
        ];
        
        paramIds.forEach(id => {
            document.getElementById(id).addEventListener('input', updateParams);
        });

    </script>
</body>
</html>
