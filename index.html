<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lumina Motion Synth</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4fd1c5;
            margin-top: -8px;
            box-shadow: 0 0 10px rgba(79, 209, 197, 0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #2d3748;
            border-radius: 2px;
        }
        input[type=range]:focus {
            outline: none;
        }
        
        .screen-container {
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
            border: 1px solid #333;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        
        /* Visual feedback for Hold Mode */
        .screen-hold-active {
            border-color: #4fd1c5;
            box-shadow: inset 0 0 30px rgba(79, 209, 197, 0.3);
        }

        /* Prevent scrolling on touch */
        body {
            overscroll-behavior: none;
            touch-action: manipulation;
        }
        
        .control-group {
            background: rgba(26, 32, 44, 0.8);
            border: 1px solid #2d3748;
            border-radius: 0.5rem;
            padding: 0.75rem;
        }

        /* Active state for touch pad */
        #touch-pad:active {
            background: rgba(79, 209, 197, 0.1);
            border-color: #4fd1c5;
        }

        .vertical-range-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* Hold Button Active State */
        .hold-active {
            background-color: #4fd1c5 !important;
            color: #1a202c !important;
            box-shadow: 0 0 15px rgba(79, 209, 197, 0.6);
            border-color: #fff !important;
        }

        /* Input Source Toggle */
        .source-btn.active {
            background-color: #4fd1c5;
            color: #1a202c;
            font-weight: bold;
        }

        /* Select Styling */
        select {
            background-color: #1a202c;
            color: #e2e8f0;
            border: 1px solid #4a5568;
            border-radius: 0.25rem;
            padding: 0.25rem;
            font-size: 0.75rem;
            width: 100%;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-300 font-sans h-screen flex flex-col overflow-hidden">

    <!-- Header & Mode Switch -->
    <header class="flex-none p-3 border-b border-gray-800 flex justify-between items-center bg-gray-900 z-10">
        <h1 class="text-xl font-bold text-teal-400 tracking-wider">LUMINA <span class="text-xs text-gray-500 font-normal">MODULAR</span></h1>
        
        <div class="flex items-center gap-2">
            <span class="text-[10px] text-teal-600 animate-pulse hidden" id="status-indicator">‚óè LIVE</span>
        </div>
        
        <button id="power-btn" class="bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-4 rounded shadow-[0_0_10px_rgba(239,68,68,0.5)] transition-colors">
            START SYSTEM
        </button>
    </header>

    <!-- Main Visual Area -->
    <div id="main-screen" class="flex-none relative h-48 bg-black screen-container w-full overflow-hidden">
        <!-- Visualizer Canvas -->
        <canvas id="visualizer" class="absolute top-0 left-0 w-full h-full z-10 opacity-80 pointer-events-none"></canvas>
        
        <!-- Video Element for Input -->
        <video id="webcam" class="absolute top-0 left-0 w-full h-full object-cover opacity-30 z-0 hidden" playsinline muted></video>
        
        <!-- Touch Surface Overlay -->
        <div id="touch-pad" class="absolute top-0 left-0 w-full h-full z-20 cursor-crosshair flex flex-col items-center justify-center p-4">
            <span class="pointer-events-none text-gray-400 text-xs select-none opacity-60 font-bold mb-1 bg-black/50 px-2 rounded text-center" id="pad-hint">
                Touch to Play
            </span>
            
            <!-- Dynamic Labels (Updated by JS) -->
            <div class="pointer-events-none text-[10px] text-teal-500 opacity-60 flex justify-between w-full absolute bottom-2 px-4 font-mono">
                <span id="label-x-low">Low</span>
                <span id="label-x-high">High</span>
            </div>
            <div class="pointer-events-none text-[10px] text-teal-500 opacity-60 flex flex-col justify-between h-full absolute right-2 py-4 items-end font-mono">
                <span id="label-y-high">High</span>
                <span id="label-y-low">Low</span>
            </div>
        </div>

        <!-- Feedback Overlay -->
        <div id="sensor-feedback" class="absolute top-2 right-2 z-30 bg-black/60 px-2 py-1 rounded text-xs text-teal-300 hidden font-mono border border-teal-900">
            IN: <span id="input-val">0</span>%
        </div>
    </div>

    <!-- Controls Container -->
    <main class="flex-1 overflow-y-auto p-4 space-y-4 pb-20">
        
        <!-- Global Controls -->
        <div class="control-group flex items-center justify-between gap-4 bg-gray-800/50">
            <div class="flex-1">
                <label class="text-[10px] font-bold text-teal-500 uppercase block mb-1">Master Volume</label>
                <input type="range" id="master-vol" min="0" max="1" step="0.01" value="0.5">
            </div>
            <div class="flex-none">
                <button id="hold-btn" class="border-2 border-teal-600 text-teal-500 text-xs font-bold py-2 px-4 rounded transition-all">
                    HOLD NOTE
                </button>
            </div>
        </div>

        <!-- NEW: MODULATION MATRIX -->
        <div class="control-group border border-teal-900 shadow-[0_0_15px_rgba(20,184,166,0.1)]">
            <h3 class="text-xs font-bold text-teal-500 uppercase mb-3 flex items-center gap-2">
                <span class="w-2 h-2 rounded-full bg-teal-500"></span> Modulation Matrix
            </h3>
            <div class="grid grid-cols-3 gap-3">
                <!-- Source 1: Camera/Tilt -->
                <div>
                    <label class="block text-[10px] font-bold text-gray-400 mb-1">Main Input</label>
                    <select id="map-input" class="focus:border-teal-500 focus:outline-none">
                        <option value="pitch" selected>Pitch</option>
                        <option value="filter">Filter</option>
                        <option value="lfoRate">LFO Rate</option>
                        <option value="lfoDepth">LFO Depth</option>
                        <option value="resonance">Resonance</option>
                        <option value="distortion">Distortion</option>
                        <option value="none">None</option>
                    </select>
                </div>

                <!-- Source 2: Touch X -->
                <div>
                    <label class="block text-[10px] font-bold text-gray-400 mb-1">Touch X</label>
                    <select id="map-touch-x" class="focus:border-teal-500 focus:outline-none">
                        <option value="pitch">Pitch</option>
                        <option value="filter" selected>Filter</option>
                        <option value="lfoRate">LFO Rate</option>
                        <option value="lfoDepth">LFO Depth</option>
                        <option value="resonance">Resonance</option>
                        <option value="distortion">Distortion</option>
                        <option value="none">None</option>
                    </select>
                </div>

                <!-- Source 3: Touch Y -->
                <div>
                    <label class="block text-[10px] font-bold text-gray-400 mb-1">Touch Y</label>
                    <select id="map-touch-y" class="focus:border-teal-500 focus:outline-none">
                        <option value="pitch">Pitch</option>
                        <option value="filter">Filter</option>
                        <option value="lfoRate" selected>LFO Rate</option>
                        <option value="lfoDepth">LFO Depth</option>
                        <option value="resonance">Resonance</option>
                        <option value="distortion">Distortion</option>
                        <option value="none">None</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Input Source Selector -->
        <div class="control-group border-teal-900/50">
            <div class="flex justify-between items-center mb-3">
                <h3 class="text-xs font-bold text-teal-500 uppercase">Input Source Config</h3>
            </div>
            
            <div class="flex bg-gray-800 rounded p-1 mb-3">
                <button class="source-btn flex-1 py-1 text-xs rounded transition-colors active" id="btn-cam-mode">CAMERA</button>
                <button class="source-btn flex-1 py-1 text-xs rounded transition-colors" id="btn-tilt-mode">TILT</button>
            </div>

            <div id="camera-controls">
                <div class="flex justify-between items-center mb-1">
                    <label class="text-[10px] text-gray-400">Sensitivity</label>
                    <button id="calibrate-btn" class="text-[10px] bg-gray-700 hover:bg-gray-600 px-2 py-0.5 rounded text-white">Calibrate</button>
                </div>
                <input type="range" id="sensitivity" min="0" max="100" value="60">
            </div>

            <div id="tilt-controls" class="hidden">
                <div class="flex justify-between items-center mb-1">
                    <label class="text-[10px] text-gray-400">Range Scale</label>
                    <button id="sensor-perm-btn" class="text-[10px] bg-teal-700 hover:bg-teal-600 px-2 py-0.5 rounded text-white hidden">Enable</button>
                </div>
                <input type="range" id="tilt-sensitivity" min="0.5" max="3.0" step="0.1" value="1.5">
            </div>
        </div>

        <!-- Oscillator -->
        <div class="control-group">
            <h3 class="text-xs font-bold text-teal-500 uppercase mb-3">Oscillator</h3>
            <div class="flex gap-2 mb-2 justify-between">
                <button class="wave-btn flex-1 py-2 bg-gray-700 rounded text-xs active:bg-teal-600 border border-gray-600" data-type="sine">Sine</button>
                <button class="wave-btn flex-1 py-2 bg-gray-700 rounded text-xs active:bg-teal-600 border border-gray-600" data-type="sawtooth">Saw</button>
                <button class="wave-btn flex-1 py-2 bg-gray-700 rounded text-xs active:bg-teal-600 border border-gray-600" data-type="square">Sqr</button>
                <button class="wave-btn flex-1 py-2 bg-gray-700 rounded text-xs active:bg-teal-600 border border-gray-600" data-type="triangle">Tri</button>
            </div>
            <div class="text-center text-xs text-teal-300" id="current-wave">Current: Sine</div>
        </div>

        <!-- Filter -->
        <div class="control-group">
            <h3 class="text-xs font-bold text-teal-500 uppercase mb-3">Filter / Distortion</h3>
            <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-xs font-bold mb-1">Base Cutoff</label>
                    <input type="range" id="filter-cutoff" min="50" max="5000" value="1000">
                </div>
                <div>
                    <label class="block text-xs font-bold mb-1">Resonance</label>
                    <input type="range" id="filter-res" min="0" max="20" value="5">
                </div>
            </div>
             <div class="grid grid-cols-1 gap-4 mb-4">
                <div>
                    <label class="block text-xs font-bold mb-1">Distortion Drive (Modulatable)</label>
                    <input type="range" id="dist-drive" min="0" max="100" value="0">
                </div>
             </div>
        </div>

        <!-- Amp Envelope (ADSR) -->
        <div class="control-group">
            <h3 class="text-xs font-bold text-teal-500 uppercase mb-2">Amp Envelope</h3>
            <div class="grid grid-cols-4 gap-2 text-center">
                <div class="vertical-range-container">
                    <input type="range" id="atk" min="0.01" max="2" step="0.01" value="0.05" class="h-20 writing-mode-vertical appearance-none" style="-webkit-appearance: slider-vertical;">
                    <span class="block text-[10px] mt-1">A</span>
                </div>
                <div class="vertical-range-container">
                    <input type="range" id="dec" min="0.01" max="2" step="0.01" value="0.2" class="h-20 writing-mode-vertical" style="-webkit-appearance: slider-vertical;">
                    <span class="block text-[10px] mt-1">D</span>
                </div>
                <div class="vertical-range-container">
                    <input type="range" id="sus" min="0" max="1" step="0.01" value="0.8" class="h-20 writing-mode-vertical" style="-webkit-appearance: slider-vertical;">
                    <span class="block text-[10px] mt-1">S</span>
                </div>
                <div class="vertical-range-container">
                    <input type="range" id="rel" min="0.01" max="3" step="0.01" value="0.5" class="h-20 writing-mode-vertical" style="-webkit-appearance: slider-vertical;">
                    <span class="block text-[10px] mt-1">R</span>
                </div>
            </div>
        </div>

        <!-- Effects -->
        <div class="control-group">
            <h3 class="text-xs font-bold text-teal-500 uppercase mb-3">Effects</h3>
            <div class="grid grid-cols-3 gap-2">
                <div>
                    <label class="block text-[10px] mb-1">Delay Time</label>
                    <input type="range" id="delay-time" min="0" max="1" step="0.01" value="0.3">
                </div>
                <div>
                    <label class="block text-[10px] mb-1">Delay Mix</label>
                    <input type="range" id="delay-mix" min="0" max="1" step="0.01" value="0.3">
                </div>
                 <div>
                    <label class="block text-[10px] mb-1">Reverb Mix</label>
                    <input type="range" id="reverb-mix" min="0" max="1" step="0.01" value="0.3">
                </div>
            </div>
        </div>

        <!-- LFO -->
        <div class="control-group">
            <div class="flex justify-between mb-2">
                <h3 class="text-xs font-bold text-teal-500 uppercase">LFO</h3>
                <select id="lfo-target" class="bg-gray-800 text-xs border border-gray-600 rounded px-1 w-24">
                    <option value="pitch">Pitch</option>
                    <option value="filter">Filter</option>
                    <option value="none">Off</option>
                </select>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-xs font-bold mb-1">Rate</label>
                    <input type="range" id="lfo-rate" min="0.1" max="20" step="0.1" value="3">
                </div>
                <div>
                    <label class="block text-xs font-bold mb-1">Depth</label>
                    <input type="range" id="lfo-depth" min="0" max="1000" value="100">
                </div>
            </div>
        </div>

    </main>

    <script>
        // --- AUDIO ENGINE ---
        let audioCtx;
        let oscillator;
        let gainNode; 
        let masterGainNode; 
        let filterNode;
        let lfo;
        let lfoGain;
        let distNode; // Distortion wave shaper
        let analyser;
        
        let delayNode, delayFeedback, delayDry, delayWet;
        let reverbNode, reverbDry, reverbWet;

        let isPlaying = false;
        let isHoldActive = false; 
        const ENVELOPE_PEAK = 0.8; 

        // --- GLOBAL INPUT STATE (Normalized 0-1) ---
        let state = {
            mainInput: 0, // Camera or Tilt
            touchX: 0.5,
            touchY: 0.5
        };

        // --- DOM ELEMENTS ---
        const video = document.getElementById('webcam');
        const visualizerCanvas = document.getElementById('visualizer');
        const mainScreen = document.getElementById('main-screen');
        const visCtx = visualizerCanvas.getContext('2d');
        const powerBtn = document.getElementById('power-btn');
        const holdBtn = document.getElementById('hold-btn');
        const touchPad = document.getElementById('touch-pad');
        const inputValDisplay = document.getElementById('input-val');
        const feedbackOverlay = document.getElementById('sensor-feedback');
        const statusIndicator = document.getElementById('status-indicator');
        const btnCamMode = document.getElementById('btn-cam-mode');
        const btnTiltMode = document.getElementById('btn-tilt-mode');
        const sensorPermBtn = document.getElementById('sensor-perm-btn');
        
        // Mappings
        const mapInput = document.getElementById('map-input');
        const mapTouchX = document.getElementById('map-touch-x');
        const mapTouchY = document.getElementById('map-touch-y');

        // Labels
        const lblXLow = document.getElementById('label-x-low');
        const lblXHigh = document.getElementById('label-x-high');
        const lblYLow = document.getElementById('label-y-low');
        const lblYHigh = document.getElementById('label-y-high');

        // --- STATE VARS ---
        let animationId;
        let inputMode = 'camera'; 
        let baseLightLevel = 128;
        
        // --- HELPER: Distortion Curve ---
        function makeDistortionCurve(amount) {
            let k = typeof amount === 'number' ? amount : 50;
            let n_samples = 44100;
            let curve = new Float32Array(n_samples);
            let deg = Math.PI / 180;
            for (let i = 0; i < n_samples; ++i) {
                let x = i * 2 / n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }

        // --- HELPER: Reverb Impulse ---
        function createReverbImpulse(duration) {
            const sampleRate = audioCtx.sampleRate;
            const length = sampleRate * duration;
            const impulse = audioCtx.createBuffer(2, length, sampleRate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);
            for (let i = 0; i < length; i++) {
                const decay = Math.pow(1 - i / length, 2); 
                left[i] = (Math.random() * 2 - 1) * decay;
                right[i] = (Math.random() * 2 - 1) * decay;
            }
            return impulse;
        }

        // --- AUDIO SETUP ---
        function initAudio() {
            if (audioCtx) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();

            // Nodes
            oscillator = audioCtx.createOscillator();
            lfo = audioCtx.createOscillator();
            lfoGain = audioCtx.createGain(); 
            filterNode = audioCtx.createBiquadFilter();
            distNode = audioCtx.createWaveShaper();
            gainNode = audioCtx.createGain(); 
            masterGainNode = audioCtx.createGain(); 
            analyser = audioCtx.createAnalyser();

            delayNode = audioCtx.createDelay(1.0);
            delayFeedback = audioCtx.createGain();
            delayDry = audioCtx.createGain();
            delayWet = audioCtx.createGain();
            reverbNode = audioCtx.createConvolver();
            reverbDry = audioCtx.createGain();
            reverbWet = audioCtx.createGain();
            
            // Defaults
            oscillator.type = 'sine';
            gainNode.gain.value = 0; 
            masterGainNode.gain.value = parseFloat(document.getElementById('master-vol').value);
            filterNode.type = 'lowpass';
            filterNode.frequency.value = 1000;
            filterNode.Q.value = 5;
            lfo.type = 'sine';
            lfo.frequency.value = 3;
            lfoGain.gain.value = 0;
            distNode.curve = makeDistortionCurve(0);
            distNode.oversample = '4x';

            reverbNode.buffer = createReverbImpulse(2.0);

            // Connections
            lfo.connect(lfoGain);
            oscillator.connect(distNode);
            distNode.connect(filterNode); // Distort before filter for grit
            filterNode.connect(gainNode);

            // Effects Chain
            gainNode.connect(delayDry);
            gainNode.connect(delayNode);
            delayNode.connect(delayFeedback);
            delayFeedback.connect(delayNode); 
            delayNode.connect(delayWet);

            const postDelay = audioCtx.createGain();
            delayDry.connect(postDelay);
            delayWet.connect(postDelay);

            postDelay.connect(reverbDry);
            postDelay.connect(reverbNode);
            reverbNode.connect(reverbWet);
            
            reverbDry.connect(analyser);
            reverbWet.connect(analyser);

            analyser.connect(masterGainNode);
            masterGainNode.connect(audioCtx.destination);

            oscillator.start();
            lfo.start();

            analyser.fftSize = 2048;
            updateBaseParams();
        }

        // Updates non-modulated controls
        function updateBaseParams() {
            if(!audioCtx) return;
            masterGainNode.gain.setTargetAtTime(parseFloat(document.getElementById('master-vol').value), audioCtx.currentTime, 0.05);
            
            // Delay/Reverb/LFO Type (Modulatable params are handled in applyModulations)
            const dTime = parseFloat(document.getElementById('delay-time').value);
            const dMix = parseFloat(document.getElementById('delay-mix').value);
            const rMix = parseFloat(document.getElementById('reverb-mix').value);
            
            delayNode.delayTime.setTargetAtTime(dTime, audioCtx.currentTime, 0.1);
            delayDry.gain.setTargetAtTime(1 - dMix, audioCtx.currentTime, 0.1);
            delayWet.gain.setTargetAtTime(dMix, audioCtx.currentTime, 0.1);
            reverbDry.gain.setTargetAtTime(1 - rMix, audioCtx.currentTime, 0.1);
            reverbWet.gain.setTargetAtTime(rMix, audioCtx.currentTime, 0.1);

            // Hard LFO routing (traditional)
            const target = document.getElementById('lfo-target').value;
            try { lfoGain.disconnect(); } catch(e){}
            if (target === 'pitch') lfoGain.connect(oscillator.frequency);
            else if (target === 'filter') lfoGain.connect(filterNode.frequency);
        }

        // --- CORE MODULATION LOGIC ---
        function applyModulations() {
            if (!audioCtx) return;

            // 1. Determine active mappings
            const map1 = mapInput.value;
            const map2 = mapTouchX.value;
            const map3 = mapTouchY.value;

            // 2. Initialize accumulators for all possible targets
            // Each accumulator stores the sum of normalized (0-1) inputs targeting it
            // count tracks how many sources target it, to average them (prevent clipping)
            let targets = {
                pitch: { sum: 0, count: 0 },
                filter: { sum: 0, count: 0 },
                lfoRate: { sum: 0, count: 0 },
                lfoDepth: { sum: 0, count: 0 },
                resonance: { sum: 0, count: 0 },
                distortion: { sum: 0, count: 0 }
            };

            // 3. Add values
            if (map1 !== 'none') { targets[map1].sum += state.mainInput; targets[map1].count++; }
            if (map2 !== 'none') { targets[map2].sum += state.touchX;    targets[map2].count++; }
            if (map3 !== 'none') { targets[map3].sum += state.touchY;    targets[map3].count++; }

            // 4. Resolve final values (Average)
            let finalValues = {};
            for (let key in targets) {
                if (targets[key].count > 0) {
                    finalValues[key] = targets[key].sum / targets[key].count;
                } else {
                    finalValues[key] = null; // No modulation active
                }
            }

            const now = audioCtx.currentTime;
            const rampTime = 0.05;

            // 5. Apply to Audio Params

            // --- PITCH ---
            if (finalValues.pitch !== null) {
                // Map 0-1 to 100Hz-1000Hz (Exp)
                const freq = 100 + Math.pow(finalValues.pitch, 2) * 900; 
                // We use pow(2) for better musical feel
                oscillator.frequency.setTargetAtTime(freq, now, rampTime);
            }

            // --- FILTER ---
            if (finalValues.filter !== null) {
                const baseCutoff = parseFloat(document.getElementById('filter-cutoff').value);
                // Modulate relative to base? Or absolute?
                // Let's do absolute override for "X-Y pad" feel, but allow base to be min.
                // Map 0-1 to 50-5000Hz
                const freq = 50 + Math.pow(finalValues.filter, 2) * 5000;
                filterNode.frequency.setTargetAtTime(freq, now, rampTime);
            } else {
                // Return to slider value
                filterNode.frequency.setTargetAtTime(parseFloat(document.getElementById('filter-cutoff').value), now, rampTime);
            }

            // --- LFO RATE ---
            if (finalValues.lfoRate !== null) {
                const rate = 0.1 + (finalValues.lfoRate * 20);
                lfo.frequency.setTargetAtTime(rate, now, rampTime);
                document.getElementById('lfo-rate').value = rate; // Visual feedback
            } else {
                lfo.frequency.setTargetAtTime(parseFloat(document.getElementById('lfo-rate').value), now, rampTime);
            }

            // --- LFO DEPTH ---
            if (finalValues.lfoDepth !== null) {
                const depth = finalValues.lfoDepth * 1000;
                lfoGain.gain.setTargetAtTime(depth, now, rampTime);
                 document.getElementById('lfo-depth').value = depth;
            } else {
                lfoGain.gain.setTargetAtTime(parseFloat(document.getElementById('lfo-depth').value), now, rampTime);
            }

            // --- RESONANCE ---
            if (finalValues.resonance !== null) {
                const res = finalValues.resonance * 20;
                filterNode.Q.setTargetAtTime(res, now, rampTime);
                document.getElementById('filter-res').value = res;
            } else {
                filterNode.Q.setTargetAtTime(parseFloat(document.getElementById('filter-res').value), now, rampTime);
            }

            // --- DISTORTION ---
            if (finalValues.distortion !== null) {
                const drive = finalValues.distortion * 100;
                distNode.curve = makeDistortionCurve(drive);
                document.getElementById('dist-drive').value = drive;
            } else {
                // Only update if changed significantly to save CPU calc
                const drive = parseFloat(document.getElementById('dist-drive').value);
                // We don't recalc curve every frame for static slider, only if mod is active
                // But for simplicity, we assume static slider is set on 'input' event
            }
        }
        
        // Handle Slider change for Distortion
        document.getElementById('dist-drive').addEventListener('input', (e) => {
             if (audioCtx) distNode.curve = makeDistortionCurve(parseFloat(e.target.value));
        });


        // --- UI LABEL UPDATER ---
        function updatePadLabels() {
            const mapX = mapTouchX.value;
            const mapY = mapTouchY.value;

            const labels = {
                'pitch': ['Low Pitch', 'High Pitch'],
                'filter': ['Dark', 'Bright'],
                'lfoRate': ['Slow', 'Fast'],
                'lfoDepth': ['Flat', 'Wobbly'],
                'resonance': ['Soft', 'Sharp'],
                'distortion': ['Clean', 'Crunchy'],
                'none': ['', '']
            };

            lblXLow.innerText = labels[mapX][0];
            lblXHigh.innerText = labels[mapX][1];
            
            // Y is usually inverted visually (bottom=low) but HTML coords top=0
            // My calculation: 1 - y/height. So top is 1 (High), bottom is 0 (Low).
            lblYHigh.innerText = labels[mapY][1]; 
            lblYLow.innerText = labels[mapY][0];
        }

        [mapInput, mapTouchX, mapTouchY].forEach(el => el.addEventListener('change', () => {
            updatePadLabels();
            // Recalc audio immediately
            applyModulations();
        }));
        
        // Init labels
        updatePadLabels();


        // --- ENVELOPES ---
        function triggerAttack() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            
            const atk = parseFloat(document.getElementById('atk').value);
            const dec = parseFloat(document.getElementById('dec').value);
            const sus = parseFloat(document.getElementById('sus').value);

            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setTargetAtTime(ENVELOPE_PEAK, now, atk / 3);
            gainNode.gain.setTargetAtTime(ENVELOPE_PEAK * sus, now + atk, dec / 3);
            
            // Note: Filter Envelope is disabled in this Modular version 
            // to allow full manual control via the Matrix without conflict.
        }

        function triggerRelease() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const rel = parseFloat(document.getElementById('rel').value);
            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setTargetAtTime(0, now, rel / 5); 
        }

        // --- INPUT PROCESSING ---

        // 1. Gyro
        function handleOrientation(event) {
            if (inputMode !== 'tilt' || !isPlaying) return;
            
            let pitch = event.beta; 
            if (pitch === null) return;
            if (pitch < 0) pitch = 0;
            if (pitch > 80) pitch = 80;

            const sensitivity = parseFloat(document.getElementById('tilt-sensitivity').value);
            let normalized = pitch / 80;
            normalized = Math.pow(normalized, 1/sensitivity);

            // UPDATE GLOBAL STATE
            state.mainInput = normalized;
            
            inputValDisplay.innerText = Math.round(normalized * 100);
            applyModulations();
        }

        // 2. Camera
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user", width: 320, height: 240 } });
                video.srcObject = stream;
                video.play();
                video.classList.remove('hidden');
            } catch (err) {
                alert("Camera error: " + err.message);
                switchInputMode('tilt');
            }
        }
        function stopCamera() {
            if(!video.srcObject) return;
            video.srcObject.getTracks().forEach(t => t.stop());
            video.srcObject = null;
            video.classList.add('hidden');
        }

        const processingCanvas = document.createElement('canvas');
        const procCtx = processingCanvas.getContext('2d');
        
        function processCameraFrame() {
            const w = 32; const h = 32;
            processingCanvas.width = w; processingCanvas.height = h;
            procCtx.translate(w, 0); procCtx.scale(-1, 1);
            procCtx.drawImage(video, 0, 0, w, h);
            procCtx.setTransform(1, 0, 0, 1, 0, 0);
            
            const data = procCtx.getImageData(0, 0, w, h).data;
            let total = 0;
            for (let i = 0; i < data.length; i += 16) { 
                total += (0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
            }
            let avg = total / (data.length / 16); 
            if (avg > baseLightLevel) avg = baseLightLevel;
            
            const sens = document.getElementById('sensitivity').value / 50; 
            let normalized = (1 - (avg / baseLightLevel)) * sens;
            if(normalized > 1) normalized = 1; if(normalized<0) normalized=0;

            // UPDATE GLOBAL STATE
            state.mainInput = normalized;
            
            inputValDisplay.innerText = Math.round(normalized * 100);
            applyModulations();
        }

        // 3. Touch
        function handleTouch(x, y, width, height) {
            if (!audioCtx) return;
            const xPercent = x / width;
            const yPercent = 1 - (y / height); // Invert Y so top is 1

            // UPDATE GLOBAL STATE
            state.touchX = xPercent;
            state.touchY = yPercent;

            applyModulations();
        }


        // --- LOOPS & EVENTS ---
        
        function loop() {
            animationId = requestAnimationFrame(loop);
            drawVisualizer();
            if (inputMode === 'camera' && video.readyState === video.HAVE_ENOUGH_DATA && isPlaying) {
                processCameraFrame();
            }
        }

        function drawVisualizer() {
            if (!analyser) return;
            const len = analyser.frequencyBinCount;
            const data = new Uint8Array(len);
            analyser.getByteTimeDomainData(data);
            const w = visualizerCanvas.width = visualizerCanvas.clientWidth;
            const h = visualizerCanvas.height = visualizerCanvas.clientHeight;
            visCtx.clearRect(0,0,w,h);
            visCtx.lineWidth=2; visCtx.strokeStyle='#4fd1c5';
            visCtx.beginPath();
            let slice = w * 1.0 / len; let x = 0;
            for(let i=0; i<len; i++) {
                let v = data[i] / 128.0; let y = v * h/2;
                if(i===0) visCtx.moveTo(x,y); else visCtx.lineTo(x,y);
                x+=slice;
            }
            visCtx.lineTo(w, h/2); visCtx.stroke();
        }

        // --- UI BINDINGS ---
        
        function switchInputMode(mode) {
            inputMode = mode;
            if (mode === 'camera') {
                btnCamMode.classList.add('active'); btnTiltMode.classList.remove('active');
                document.getElementById('camera-controls').classList.remove('hidden');
                document.getElementById('tilt-controls').classList.add('hidden');
                window.removeEventListener('deviceorientation', handleOrientation);
                if(isPlaying) startCamera();
            } else {
                btnTiltMode.classList.add('active'); btnCamMode.classList.remove('active');
                document.getElementById('tilt-controls').classList.remove('hidden');
                document.getElementById('camera-controls').classList.add('hidden');
                stopCamera();
                if(isPlaying) {
                    window.addEventListener('deviceorientation', handleOrientation);
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        sensorPermBtn.classList.remove('hidden');
                    }
                }
            }
        }
        btnCamMode.onclick = () => switchInputMode('camera');
        btnTiltMode.onclick = () => switchInputMode('tilt');

        // Touch Listeners
        let isTouching = false;
        const startT = (e) => { 
            e.preventDefault(); if(!isPlaying) return;
            isTouching = true; if(!isHoldActive) triggerAttack();
            const r = touchPad.getBoundingClientRect();
            // Handle multi-touch or mouse
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            handleTouch(clientX - r.left, clientY - r.top, r.width, r.height);
        };
        const moveT = (e) => {
            e.preventDefault(); if(!isTouching) return;
            const r = touchPad.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            handleTouch(clientX - r.left, clientY - r.top, r.width, r.height);
        };
        const endT = (e) => {
            if(e) e.preventDefault();
            isTouching = false; if(isPlaying && !isHoldActive) triggerRelease();
        };

        touchPad.addEventListener('mousedown', startT);
        touchPad.addEventListener('mousemove', moveT);
        touchPad.addEventListener('mouseup', endT);
        touchPad.addEventListener('mouseleave', endT);
        touchPad.addEventListener('touchstart', startT, {passive:false});
        touchPad.addEventListener('touchmove', moveT, {passive:false});
        touchPad.addEventListener('touchend', endT);

        // System Start/Stop
        powerBtn.onclick = () => {
            if (!isPlaying) {
                initAudio(); audioCtx.resume(); isPlaying = true;
                feedbackOverlay.classList.remove('hidden');
                statusIndicator.classList.remove('hidden');
                if(inputMode==='camera') startCamera(); 
                else window.addEventListener('deviceorientation', handleOrientation);
                powerBtn.innerText = "STOP SYSTEM";
                powerBtn.classList.replace('bg-red-500','bg-green-500');
                loop();
            } else {
                isPlaying = false; triggerRelease(); stopCamera();
                window.removeEventListener('deviceorientation', handleOrientation);
                feedbackOverlay.classList.add('hidden');
                statusIndicator.classList.add('hidden');
                powerBtn.innerText = "START SYSTEM";
                powerBtn.classList.replace('bg-green-500','bg-red-500');
                cancelAnimationFrame(animationId);
                isHoldActive = false;
                holdBtn.classList.remove('hold-active');
                mainScreen.classList.remove('screen-hold-active');
            }
        };

        holdBtn.onclick = () => {
            if(!isPlaying) powerBtn.click();
            isHoldActive = !isHoldActive;
            if(isHoldActive) {
                holdBtn.classList.add('hold-active');
                mainScreen.classList.add('screen-hold-active');
                triggerAttack();
            } else {
                holdBtn.classList.remove('hold-active');
                mainScreen.classList.remove('screen-hold-active');
                if(!isTouching) triggerRelease();
            }
        };

        // Calibrate
        document.getElementById('calibrate-btn').onclick = () => {
             if(inputMode === 'camera' && isPlaying) {
                 baseLightLevel = 255; 
             }
        };
        
        // Sensor Perms
        sensorPermBtn.onclick = () => {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(r => {
                    if(r==='granted') { window.addEventListener('deviceorientation', handleOrientation); sensorPermBtn.classList.add('hidden');}
                });
            }
        };

        // Params listeners
        const paramIds = ['master-vol', 'delay-time', 'delay-mix', 'reverb-mix', 'lfo-target'];
        paramIds.forEach(id => document.getElementById(id).addEventListener('input', updateBaseParams));

        document.querySelectorAll('.wave-btn').forEach(btn => {
            btn.onclick = (e) => {
                if(oscillator) oscillator.type = e.target.dataset.type;
                document.querySelectorAll('.wave-btn').forEach(b => b.classList.remove('bg-teal-600', 'border-teal-400'));
                e.target.classList.add('bg-teal-600', 'border-teal-400');
                document.getElementById('current-wave').innerText = `Current: ${oscillator.type}`;
            };
        });
        document.querySelector('[data-type="sine"]').classList.add('bg-teal-600', 'border-teal-400');

    </script>
</body>
</html>
